js是什么：
    js（JavaScript）是运行在客户端的编程语言（脚本语言）、弱类型（动态）语言，是解释型语言，解释型语言就是执行一行代码就立即转换成机器语言，并执行返回结果，有点像吃火锅，边吃边下菜加工，同时进行，和编译型语言不同。
    编译型语言就是全部先转换成机器语言，再执行，没转换完成，程序不会执行的，像炒菜，都炒好再吃饭。
js运行环境：
    js是运行在浏览器上的，浏览器本身并不会执行js代码，而是通过内置的JavaScript引擎（解释器）来执行js代码，js引擎执行时会逐行将js代码转换为源码（机器语言0或1），然后由计算机去执行。

    计算机执行程序：
        ctrl+s保存时，程序代码是被保存到磁盘里的，
        程序是运行在内存空间里的，是被CPU执行的。
        执行程序时，cpu是无法直接读取磁盘里存储的数据的，它只可以读取内存空间里的数据，
        所以先从磁盘读取数据到内存中，再被CPU或GPU（都相当于计算器是做运算的）运行。
    编程：
        程序在运行的时候必需占用内存空间，如何合理的占用内存空间就是编程的意义，
        也就是说编程是合理的分配内存空间来运行程序。
        

js执行顺序：
    js代码运行顺序是从上到下，逐行执行。整个js文件，如果执行到某一处报错，它下面的js代码都不会执行。
浏览器构成：
    浏览器分为2部分：
        渲染引擎：也叫内核，用来解析html和css的。
        js引擎：也叫js解释器，用来读取网页中的js代码，对其处理后运行。
js书写位置，3种：
    行内式：
        在标签里写on开头的属性，例如onclick（鼠标单击）属性，属性值用" "引起来，引号里面写js输入输出语句，用( )括起来，括号里的字符串用' '引起来,如下：。
            onclick="alert('字符串')"
    内嵌式：
        在html的head标签内写script标签，在script标签里写js代码，所有js代码都以分号结束，如下：
            <script>
                js代码....;
            </script>
    外部引入式：
        创建后缀为.js的文件，将文件用<script>标签的src属性引入，src属性里写js文件路径，script是个双标签，引入外部文件时标签中间不能写代码。如下：
            <script src="文件名.js"></script>

js严格模式：
    写在哪个作用域下，在哪个作用域生效。尽量不要写在全局模式下，否则引用任何js文件都变成严格模式了。
    语法：
        "use strict";
    用严格模式的变化：
        1.声明变量时，必需加var，否则报语法错误；
            不严格模式下，函数内部不写var声明的变量可以全局使用。
        2.函数形参不能重名，否则报语法错误，
            不严格模式下函数形参重名，后面的形参覆盖前面的形参；
        3.arguments对象不允许被动态改变，只能存调用函数时传的实参，即使函数内部对形参重新赋值，arguments存的值仍然是传入的实参，而不是重新赋的值。
            不严格模式下，函数内部对形参重新赋值，arguments存的函数实参值也会跟着改变。
        4.保留字不能作为用户自定义变量名，否则报此变量名是保留字，不能使用的错误，
            不严格模式下，用保留字作为用户声明变量时的变量名，也能用，不会报错。

js常用的输入输出语句：
    这4种方法都是归属window浏览器的。
    输入：
        prompt():浏览器弹出输出框，用户可以在输入框内输入数据；收集用户输入数据给程序验证的。
    输出：
        alert():浏览器弹出警示框；输出的，展示给用户看的。
        console.log():浏览器控制台打印输出信息；在浏览器控制台输出的，给程序员调试代码用的。
                    很多情况下各大企业招聘信息也喜欢放在这里输出；
                      每个要输出的内容之间用,隔开，例如：
                        console.log(a,b,c...)
        document.write():在当前页面上输出内容，如果括号里传的参数含有标签，会自动解析，渲染标签，如果不想渲染标签需要将标签的左右尖括号用&lt。                


数据存储单位：
    bit < Byte < kb < GB < TB <...
    bit（位）：是最小的存储单位，1bit可以保存一个0或者1
    Byte（字节）：1B = 8b
    KB（千字节）：1KB = 1024B
    MB（兆字节）：1MB = 1024KB
    GB(吉字节)：1GB = 1024MB
    TB(太字节)：1TB = 1024GB

js的常量和变量：
    常量：
        值不可以被修改的叫常量；
        js的简单、复杂、特殊数据类型都代表常量。
    变量：
        值可以被修改的叫变量。

js数据类型：
    在计算机中，不同类型的数据所占的存储空间不同，为了优化存储，给不同大小的数据分配不同大小的存储空间，所以要定义不同的数据类型来区分。

    变量的数据类型是由js引擎根据变量值来判断的，运行完这行变量 = 变量值;的代码后，变量就确定了数据类型，
    变量的数据类型决定了将在内存中划分多少空间来存储变量值，
    变量的数据类型是动态的，会根据赋不同的变量值而改变，同一个变量，前面的值会被覆盖，数据类型以最后一次变量值为准来划分存储空间。

js数据类型，两大类：
    1.简单数据类型，共5种：
        又叫基本数据类型或值类型，存储在内存的栈中，存储变量时直接存的是值。
        简单数据类型也有方法和属性，因为js把简单数据类型包装成了复杂数据类型，这种行为又叫做：基本包装类型。
        当把存简单数据类型的变量作为函数的实参时，相当于把变量在栈里存的值复制了一份给形参，这时在函数内部怎么修改形参的值，都不会影响到或改变外部那个简单数据类型的变量值。

        Number:数字类型，（默认值0）包含整型和浮点型；
            Int整型：只能是整数
            Float浮点型：小数。

            数字型进制有：二进制（0b），八进制(0o)，十进制，十六进制(0x),
                十进制转二进制：模二取余法来算，商为0时结束运算，至下往上取每个余数连起来组成二进制数。
                js中将数字值转换成 八进制前面加0表示，十六进制前面加0x表示。

            数字型范围：数值的最大值和最小值。
                Number.MAX_VALUE:最大值，1.7976931348623157e+308。
                Number.MIN_VALUE：最小值，5e-324。
            
            数字型三个特殊值：
                Infinity:代表无穷大，大于任何数值。（计算机除法时，除数可以为0，正数除0得到）
                -Infinity：表示无穷小，小于任何数值。（负数除0时得到）
                NaN（Not a number）:代表一个非数值。
            isNaN()方法是用来判断非数字的，有返回值false或true，是数字返回flase，不是数字返回true。


        Boolean:布尔值类型，（默认值false）,两个值:true（1）和flase（0）,（js里两个值的首字母要小写），这两个值可以直接用来和其它数字做数学运算；
        
        String:字符串类型，只要带单引号''或双引号""的都叫字符串，
            (默认值 "" ), ，js里建议使用单引号，因为html里用双引号。

            字符串声明：
                1.通过 new String();得到object对象类型。
                2.通过省略new操作符，直接用String()声明;得到string类型。
                3.字符串常量声明，也就是通过字面量''或""声明；得到string类型。

            字符串引号嵌套：
                必须是外双内单，或外单内双，否则报错。

            字符串的不可变：
                字符串是只读的，变量只存值的内存空间地址，值字符串存在内存的只读数据段里。
                字符串的值是不可变的，操作字符串后看上去字符串的内容变了，实际上是内存地址变了，系统在内存的栈中从新开辟了一个空间，存操作后的新字符串。
                也就是一个变量存的是字符串值，从新给这个变量赋值，它之前的字符串值不会被修改，也不会被销毁，依然在内存中。所以由于字符串的不可变，多次修改字符串值，会很占内存，导致电脑慢、卡。
                循环生成字符串，赋值给变量时也是很占内存空间的，每循环赋值一次，就存下一个字符串，循环多少次，实际上在内存里存了多少个字符串类型的值，而不是只存了一个 最后循环完生成的 那个我们需要的字符串值。
            
            字符串拼接：
                多个字符串之间用 + 进行拼接，字符串可以用 + 拼接任何数据类型，得到的都是新的字符串类型。
                + 在字符串类型里是相连，在数字类型里是相加。

            字符串转义，转义符都是\开头的：     
                \n :换行，n是newline的意思。
                \t ：缩进，t是tab
                \b :空格，b是blank
                \\ :一个斜杠
                \' : 单引号
                \" :双引号

            计算字符串长度，写法：
                存字符串值的变量名.length
                    计算长度时从1开始数的。
    特殊数据类型：
        Undefined:未定义类型，声明了变量没有赋值就会产生此数据类型，也可以直接给变量赋值为undefined类型。这个数据类型是表示一种状态。

        Null:空类型，声明了变量并赋值为null，表示变量的值为空，后面可以按需求给变量赋其它的值覆盖空值，返回值是object空对象。

        NaN: 不是一个数字（not a number 的缩写）

    2.复杂数据类型：
        又叫引用类型，要通过new操作符来创建的。
            如果将复杂数据类型的变量作为参数传给函数做实参，相当于把变量的地址复制给了函数的形参，这时形参和实参保存的是同一个堆地址，所以操作的是堆里的同一个变量值数据，此时给形参或实参哪个赋值，都会改变对应的堆地址里存储的数据。
        在内存中的存储是：
            在栈中存储变量的值对应的堆地址，这个地址是系统自动分配的二进制地址，
            再去堆里存储变量的值（对象）。

        Object（对象）
        Array(数组)
        Date（时间日期）

查看数据类型，3种方法：
    1. typeof用来查看数据类型的，返回值是变量的数据类型，语法：
        typeof 变量名
    2. 直接在控制台根据输出数据的颜色看：
        字符串是黑色，
        数字类型是蓝色，
        布尔值是深蓝色，
        未定义类型和空类型是灰色。
    3.字面量，就是通过字面就能直接看出这个值是什么数据类型，字面量是在源代码中一个固定值的表示方法。
强制转换数据类型：
    转换成字符串类型，4种方法：
        变量名.toString();
        String(要转换的变量名或内容);
        + 隐式转换，和字符串拼接的结果都会是字符串，这种最常用;
        join('参数可以自己指定分隔符') 是针对把数组转换成字符串的，不写参数默认用,进行分隔。

    转换成数字类型，要求必需是以数字开头的，否则不转换，直接返回NaN，6种方法：
        parseInt(要转换的变量名或内容)：转换成整数类型，会自动取整，把后面的小数或单位等其他内容都去掉。
            如果是数字开始的字符串，转换时可以得到开始的数字部分，能成功转换成整数数字类型。
            如果不是数字开始，但里面含有数字的字符串，也会得到NaN。
            例如：
                parseInt('100a2b') 得到数字类型的整数100，这里可以成功将字符串转换成整数数字类型。
                parseInt('a100') 得到NaN。

            进制转换,将各种进制数转换成10进制：
                parseInt(参数1传需要被转换的数，参数2传第一个参数是几进制的进制数);
                例如：
                    str = '110100' 是一个二进制的数
                    parseInt(str,2); 表示将二进制的110100数，转换成10进制数，得到52。        

        parseFloat(要转换的变量名或内容)：转换成浮点数类型，会保留小数部分，也会自动把后面的单位或其它字符都去掉。
        number(要转换的变量名或内容)：强制转换成数字类型
        - 或 * 或 / 号，隐式转换，利用数学运算将字符串类型的数值转换成数字类型，例如：
            var num = '12' - 0; 得到的结果是数字12。

    转换成布尔型：
        Boolean()
        只有5个特定的值会被转换为flase，代表空、否定的值，如下：
            ''、 0、NaN、null、undefined;
        其它值都会被转换为true。

表达式：
    任何数据和运算符组成的式子叫做表达式。
    表达式的特征：
        表达式一定会有返回值，
        表达式是实现什么功能的。

运算符，6种：
    算术运算符，5种：
        + - * / %(取余，取模，后期主要用于判断一个数能否被另一个数整除，能整除余数为0。)

        自动数据类型转换：
            作用是将不同数据类型进行算术运算。
            算术运算时不同数据类型是没办法进行运算的，表达式在运行时系统自动将不同数据类型转换成同一种数据类型，再进行计算。
            2种情况：
                1.表达式中有一个数据类型是字符串时，做+法，其它数据类型都会被转成字符串类型，进行字符串拼接；
                    做-法，字符串类型会被转换成数字类型，如果转换不了的，就转成特殊类型NaN,任何数据和NaN运算结果都是NaN。
                2.表达式中不含字符串数据类型的，在进行算术运算时，都先转成数字，再进行运算。
                    true是1，flase是0，null是0，转换不了的运算结果是NaN.

        注意：
            浮点数在算术运算时会有精度问题，是计算机解决不了的bug，因为程序会转换成二进制数据再进行运算，导致运算结果会出现最高17位小数的返回值。尽量不要做浮点数运算，也一定不要直接判断两个浮点数是否相等。
            例如：
                a = 0.3;
                b = 0.1 + 0.2;
                a == b; 会返回false，因为b的计算结果是0.30000000000000004，和0.3是不相等的。
            js除法时，除数可以为0，
                正数除0得到Infinity（代表无穷大，大于任何数值。）
                    除了字符串类型以外的任何数值和它做算术运算，得到的值都是infinity；
                负数除0时得到-Infinity（表示无穷小，小于任何数值。）
                    除了字符串类型以外的任何数值和它做算术运算，得到的值都是-infinity；

    一元运算符（递增和递减运算符），4种：
        是为了简写 （变量 = 变量 + 1;）的运算符， 开发时，大多使用后置递增/减，并且代码独占一行，例如：num++;或num--;

        递增（++）：表示给变量自加1，必需和变量一起使用，单独运算时，运算结果相同，和其它表达式一起运算时，结果完全不同，两种写法：
            ++变量名 表示前递增，先自加1，再和其它变量运算，并返回值。
            变量名++ 表示后递增，先原值和其它变量运算，并返回值，再自加1.
        递减（--）：表示给变量自减1，必需和变量一起使用，单独运算结果相同，和其它表达式一起运算结果不同，两种写法：
            --变量名 表示前递减，先自减1，再和其它变量运算，并返回值。
            变量名-- 表示后递减，先和其它变量运算，并返回值，再自减1。

    比较运算符（关系运算符），两两比较，返回值是布尔值，8种：
        < 小于
        > 大于
        >= 大于等于
        <= 小于等于
        == 等于，会隐式转换数据类型，只要两边的值相等，返回结果就是true。
            例如：'16'== 16;结果是true。
        === 全等于，必需要两边的值和数据类型都相同，才会返回true。
        != 不等于
        !== 全不等于
        
        
        比较运算符的自动数据类型转换，在运算时，如果进行非数值比较，要遵循以下规则：
            1.两个操作数都是数值，则直接数值比较；
            2.两个操作数都是字符串，则比较两个字符串对应的ASCII码值；
                （1.如果是两个单字符进行比较，直接比较字符的ASCII码值；
                （2.如果是两个字符串进行比较，会逐位进行比较字符的ASCII码值，比较出大小，就直接返回结果，后面剩下的字符就不再进行比较了。
            3.两个操作数有一个是数值，则将另一个转换为数值，再进行数值比较；
            3.如果有一个操作数是NaN，==比较时返回false，!=时返回true,
                并且直接将两个NaN进行比较，NaN == NaN也是false;
        
        注意，要记住的一个特殊的比较运算：
            null = undefined 返回true。

    赋值运算符，6种：
        = 直接赋值，
        += 、-= 、*= 、/= 、%= 先做（加或减或乘或除或取余等）运算后再赋值给变量。

    
    逻辑运算符，返回值是布尔值，3种：
        &&  与、and
        ||  或 、or
        !  非 、not  对表达式的运算结果取反。

        短路运算：
            &&逻辑运算时，只要第一个值的运算结果是false，就会不再继续下面的运算，直接返回第一个false值，这种现象较短路运算（也叫逻辑中断）；如果第一个值是true，会继续向下执行，并返回最后一个表达式的值。例如：
                123 && 456; 第一个值是true，会继续向下执行，并返回最后一个值，所以返回结果是456。
                0 && 456; 第一个值是flase，会短路，直接返回第一个值，所以返回结果是0。
            ||逻辑运算时，只要有一个值满足true的条件，就会逻辑中断，直接返回这个值，不再继续向下运算。例如：
                123 || 456;第一个值是true，会短路，直接返回123。
                null || 456 || 789;第一个值是false,继续向下执行，直到某个值为true，返回这个值，并停止运算。这里第二个值为true，所以返回结果是456。
        
    三元运算符,通过？和：组成的三元表达式，可以做简单的条件判断，类似if...else双分支语句的简写，
    语法：
        条件表达式 ？ 表达式1 : 表达式2 
        比较像if、else双分支语句的功能，如果条件表达式结果为true，返回表达式1的值，否则返回表达式2的值，例如：
            var num = 10;
            result = num > 5 ? '是的' : '不是的';  10大于5，判断结果为true，所以返回表达式1的值。
            result = num < 5 ? '是的' : '不是的';  10是大于5的，判断结果为flase，所以返回表达式2的值。

运算符优先级：
    1.（）小括号优先级最高
    2.++ -- ！这3个一元运算符,一元运算符是只有一个对象和运算符号进行运算。
    3.算术运算符，先乘除后加减，两元运算符，两个对象通过运算符进行运算。
    4.关系运算符，> >= < <=
    5.相等运算符，== != === !==
    6.逻辑运算符，先&&后||
    7.赋值运算符
    8.逗号运算符，就是声明多个变量时用，隔开的那个逗号。


标识符：
    所有用户自定义的（变量、属性、函数、参数的）名字都是标识符。

标识符命名规范：
    由字母(A-Za-z)、数字（0-9）、下划线 _ 、美元符号 $ 组成的。
    大小写敏感，不能以数字开头，不能是js关键字保留字，
    单词个数两个或两个以上的名字，遵循驼峰命名法（首个单词首字母小写，其它单词首字母必需大写）或下划线连接命名法（单词之间用_连接，可以都小写）。
    不能使用 name 为变量名，因为在很多浏览器里name有特殊意义，容易冲突。

关键字：
    关键字是被系统征用的有特殊功能的单词。
保留字：
    保留字是被系统征用但还没想好干什么用的单词。
        
什么是变量：
    变量相当于一个储存数据的容器，是程序在内存中申请一块用来存放数据的空间。
    js变量是弱引用类型，赋什么数据类型的值，这个变量就是什么数据类型。
声明变量：
    var（variable）是js里的一个关键字，用来声明变量的，
    用该关键字声明变量后，计算机会自动为变量分配内存空间，来存储变量值的数据。
    声明变量以;结束，
    声明多个变量之间用,隔开。
    变量名是自己定义的，我们可以通过变量名来访问内存中为此变量分配的空间。

    声明一个变量：
        var 变量名; 
    声明多个变量：
        var 变量名1,
            变量名2,
            变量名3;
    注意：只声明变量，不赋值，在控制台输出得到的结果是undefined(未定义数据类型)，因为程序也不知道里面存的啥，这个不赋值比赋null空值的运行效率要慢一点，优化运行速度可以先用null占位置，所以不知道要给变量存什么值时可以先存个null。
         不声明变量、不赋值，直接使用程序会报错。
         不声明变量，直接赋值使用，程序能正常执行，并返回值，但不建议这样做，不符合规范，隐患大。
变量赋值：
    通过 = 号给变量赋值，值后面以;结束，赋值是把右边的值给左边的变量，如下：
        age = 18;
变量初始化：
    声明一个变量，并同时给它赋值，称为变量的初始，如下：
    var age = 18;

更新变量：
    更新变量的值时最好是相同数据类型的值，便于阅读，因为变量名取名建议是用能见名思意的单词。
    相同的变量，值以最后一个变量为准，例如：
        var myname = '小丽';
            myname = '小明';
    

js流程控制：
    就是控制代码按照什么结构顺序来执行，在一个程序执行的过程中，代码的执行顺序对结果是有直接影响的，我们可以控制代码的执行顺序来实现我们要完成的功能，有3种结构：
        顺序结构，从上到下逐行执行，普通的程序代码都是按照顺序结构来执行的。
        分支结构，通过分支语句里的判断条件是否为true，来决定执行哪个分支里的代码。
        循环结构,重复执行循环语句里的代码。

    分支，2种：
        if语句，多分支语句，用来判断的，多选一来执行判断条件为true的分支语句里面的代码，语法：
            if (判断条件表达式1) {
                条件为true时执行的代码...;
            } else if (判断条件表达式2) {
                上面的条件不为true时，这个条件为true时执行的代码...;
            } else if (判断条件表达式3) {
                上面的条件不为true时，这个条件为true时执行的代码...;
            } else {
                以上所有条件表达式都不满足不为true时执行的代码...;
            }

        switch语句，是多分支语句，用来匹配多个确定的值的，针对表达式设置一系列的特定值的选项时可以使用switch，语法：
            switch (表达式) {
                case value1:
                    和表达式的值全等于时执行此代码，否则继续向下执行;
                    break;
                case value2:
                    和表达式的值全等于时执行此代码，否则继续向下执行;
                    break;
                ....可以写n多个case：
                    和表达式的值全等于时执行此代码，否则继续向下执行;
                    break;
                default:
                    以上的值都不匹配，则执行default控制的代码;
            }
            case后面的value值一般是写常量，一定是和表达式的值全等于，才能匹配，值后面一定要写冒号，每个case后面都要写break。
            break是执行完某个相匹配的值控制的代码后退出switch的作用，如果哪个case下面没写break，程序不管表达式的值是否能匹配，都会继续向下执行，直到遇到break或者default才会退出switch语句。

        if用来判断范围的，更加灵活，分支比较少时，效率高，分支较多时，会从上到下依次判断，效率比switch低；
        switch是能确定值的情况下，用来判断表达式的值全等于哪个case值的，分支较多时，程序会直接跳到能匹配的case值，执行这个case值控制的代码，执行效率高.

    循环语句，循环由循环条件和循环体组成，3种：
        for循环，把一些代码重复执行若干次，通常和计数有关，语法：            
            for (初始化变量也就是计数器; 循环终止条件表达式也就是判断条件; 操作表达式也就是累加器) {
                    循环体;
                }

                执行顺序是：
                    第一次循环：
                        1.计数器，作为初始值，在整个循环中只执行一次。
                        2.循环终止条件
                        3.循环体
                        4.累加器，是整个循环中最后执行的代码。
                    第二次循环 —— 第n次循环：
                        1.每次循环体执行结束后更新累加器
                        2.循环终止条件
                        3.循环体       
            每次循环时更新的累加器和循环终止条件进行比较，满足判断条件继续执行循环体，不满足终止条件时自动退出循环。
        
        双重for循环，也就是for循环嵌套，语法：
            for(初始化变量; 循环终止条件; 操作表达式) {
                for (初始化变量; 循环终止条件; 操作表达式) {
                    循环体
                }
            }
            执行顺序：外层循环执行一次，内层循环执行全部；
                例如：
                    第一次循环，外层循环开始，满足条件进入内层循环，内层循环会执行到不满足循环条件退出内层循环，
                    再执行第二次外层循环，满足条件进入内层循环，内层循环执行到不满足循环条件退出内层循环，
                    开始第三次外层循环.....

        while循环，语法：
            var 初始变量;
            while(条件表达式也就是循环终止的判断条件) {
                循环体
                操作表达式也就是累加器，必需要写，否则死循环。
            }

        do...while循环，语法：
            var 初始变量;
            do {
                循环体;
                累加器;
            } while(条件表达式);

            do..while的执行顺序：
                先执行一次，再判断循环条件。
                也就是先执行一次do控制的循环体，再对while控制的条件表达式进行判断，如果条件为true，则继续执行循环体，否则退出循环。
            while后面的;千万不能省略。


    循环的判断条件里，如果有未赋值的变量，解释器会自动赋值，值为undefined，这个undefined就是一个特殊的值，而不是字符串'undefined'。
    下面是例子：
        /* 
        js里var声明的变量会提升到作用域的最顶端，不管写在代码的哪个位置都会提升到作用域的顶端。
        如果循环条件为 while (aa == 'undefined'){}，是无法进入循环体的。
        如果循环条件为 while (aa == undefined){}，就能进入循环体,
            因为没进入循环体前aa是声明了未赋值的变量，会被自动赋值undefined。
            进入循环体后,通过var aa = prompt()用户输入的内容，aa才被赋值，任何值都不能满足==undefined的判断条件，所以循环会因不满足条件而结束循环。
        如果循环条件为 while (aa !== undefined){}，就不能进入循环体。
        如果循环条件为 while (aa !== xxx){}，就能进入循环体，其中，xxx代表undefined之外的任何值。
         */
        while (aa == undefined) {
            /* 
            因为声明了aa这个变量还未赋值，js会自动将变量aa赋值为undefined，所以能够进入循环体，
            注意：这里的undefined不是字符串undefined，
            */
            console.log(aa);

            // 因为变量aa未赋值，所以typeof aa的输出结果是undefined。
            console.log(typeof aa);

            console.log('haha');

            //js里var声明的变量会提升到作用域的最顶端，不管写在代码的哪个位置都会提升到作用域的顶端。
            // 变量aa在这里才被赋值，用户输入什么赋值给变量aa都是字符串类型，不能满足循环判断条件，判断条件不能成立，就无法进入循环。
            var aa = prompt('输入什么赋值给变量aa都不能满足循环判断条件，会结束循环');
            // 如果声明变量不赋值，值默认是undefined，永远满足while (aa == undefined){}，会进入死循环。
            // var aa;
        }


    打循环的断点：
        打开浏览器控制台 —— Sources —— 点击左侧的文件名 —— 在中间区域显示的代码里点击循环那 一 行代码行数 —— 代码上出现各种颜色的小圆圈 —— 刷新浏览器 —— 断点所在位置会显示蓝色背景色 —— 点击右侧的向下箭头↓来查看代码下一步执行的断点 —— 程序会按来↓执行，点一下执行一步而不是一次性执行完整个循环语句 —— 鼠标停在累加器变量名上可以查看累加器的目前值，或者在右侧的Watch ——点击 + 号 —— 输入累加器变量名 —— 累加器的值会显示在watch里，并且自动随着循环次数更新 —— 点击行数取消断点 —— 刷新浏览器 —— 程序会恢复正常执行。

    关键字break和continue，常用于循环或判断里:
        continue(继续):退出本次循环，遇到continue后本次循环下面的代码都不执行，直接进行下一次循环。
        break（终止）：退出所有循环，遇到break后剩下的所有循环次数都不再执行，直接退出循环；
                      如果是循环嵌套，内层循环里写break，只退出内层循环；
                      如果是循环嵌套，外层循环里写break，会退出所有循环。


数组（Array）：
    数组就是一组数据的集合，存储在单个变量中，也就是列表；

    创建数组的3种方式：
        第一种，用new Array构造函数创建：
            var 变量名 = new Array(元素1,元素2...);

        第二种，省略new操作符，直接用Array对象创建：
            var 数组名 = Array(元素1,元素2...);

            注意,以上两种都是：
                括号里传一个参数，表示数组长度，得到的是数组长度个空元素。
                括号里传两个及以上的参数，才表示数组元素。

        第二种，用字面量[]创建：
            var 变量名 = [元素1,元素2...];
        
        数组里的元素可以是任何数据类型，
        每个元素之间用,隔开。

    索引（下标）：
        用来访问（获取）数组的元素的序号，通过索引，索引从0开始。语法：
            变量名[索引号]

            如果数组里有3个元素，获取数组元素时输入4，得到结果是undefined；

    检测一个变量存的值是否为数组类型，2种方式返回值都是true或false，如下：
        1. instanceof是一个运算符(单词是实例、某种类别的实例、运算符的意思)，前面只能写一个检测对象，写法：
            需要检测的变量名或其它参数 instanceof Array;

        2. Array.isArray()，优先级比instanceof高，是h5新增的方法，ie9以上的版本才支持，写法：
            Array.isArray(需要检测的变量名或其它参数);
       
    遍历数组中的元素：
        用循环来遍历数组，取出它的每一个元素，写法：
            for (var i = 0; i > 数组元素的长度; i++) {
                console.log(变量名[i]);
            }
        或：for (i in 数组名) {
            console.log(数组名[i])
        }

    将数组变量赋值给其它变量：
        其实是将数组变量存的内存地址复制给另一个变量，所以它们存的是相同的内存地址，指向同一内存地址存的元素。修改任何一个数组的元素，另一个数组会跟着变。

    新增数组元素，两种方法：
        第一种：通过修改  数组.length（长度）新增数组元素；
                length属性是可以读写的；
                如果给数组length增加后，没有给新增的索引号赋值，默认是empty（空元素），empty的默认值是undefined。
                例如：var arr = [1,2,3]; 这个数组长度为3，
                      arr.length = 5;  将数组长度扩容到5，会产生两个empty元素，这两个empty的默认值是undefined。
        
        第二种：通过修改数组索引的方式新增数组元素：
            数组名[索引号] = 元素值；
                注意：
                    如果原数组索引号不存在，表示新增数组元素，
                    如果数组原索引号存在，表示替换原索引号对应的数据，
                    不能直接给数组名赋值，否则会覆盖掉数组原来的数据。

        第三种：通过push()方法在数组元素的末尾新增数组元素：
            数组名.push(新元素1，新增元素2...);
                注意：
                    返回值是新数组的长度，
                    参数传需要追加到原数组结束位置的新元素,可以同时添加一个或多个元素。

        第四种：通过unshift()方法在数组元素的前面新增数组元素：
            数组名.unshift(新元素1，新增元素2...);
                注意：
                    返回值是新数组的长度，
                    参数传需要追加到原数组开始位置的新元素，可以同时添加一个或多个元素。

冒泡排序：
    是一种简单的排序算法，将元素从大到小或从小到大排序。
    规则：
        前后两个数两两进行比较，如果符合条件就交换两个数的位置，
        它重复走访要排序的元素数列，一次比较两个元素，把元素们按表达式规定的顺序交换并排列好，直到没有再需要交换顺序的元素，完成排序。
    写法：
        var 数组名1 = [元素1，元素2，元素3]， 需要重新排序的原数组，
            数组名2 = [];                    临时变量，存需要交换顺序的元素，

        外层循环的功能是比较的轮数，比较的轮数 = 数组的长度 - 1。
        for(var i = 0; i <= 数组名1.length - 1; i++) {

            内层循环的功能是实现每一轮交换多少次，
            每一轮比较的次数 = 数组长度 - 当前的轮数（当前轮数是从1开始的，但记录轮数的i是从0开始的，所以i + 1，i是0时，i+1表示第一轮）。
            也就是原数组里有多少个元素，就要把外层循环的原数组索引为i的元素，与原数组里的剩余每个元素进行大或小的比较。
            也可以写成：length（数组长度） - 1（索引为i的元素自己，自己不用与自己比大小，所以要减掉1）- i（每次外层循环的元素索引号）。
            for (var j = 0; j <= 数组名1.length - 1 - i; j++) {

                判断条件决定元素们怎么排序，
                >号表示从小到大排序，
                <号表示从大到小排序。
                判断条件里的：数组名1[j]表示前一个数，数组名1[j + 1]表示后一个数，它们两两进行比较大小。

                if (数组名1[j] >或< 数组名1[j + 1]) {

                    借用临时变量，并通过索引号不同，来交换前一个索引为j的元素，和后一个元素索引为j+1的元素的值，实现排序位置变换。
                }
            }
        }
        console.log(数组名1);

选择排序：
    是一种简单的排序算法，将元素从大到小或从小到大排序。
    选出一个数，将它与数组里的每一个数进行比较，再按排序条件交换它与每个数的位置。
    比较的轮数 = 数组的长度 - 1；
    每一轮比较的次数 = 数组长度 - 当前的轮数。
    写法：
        var 数组名1 = [元素1，元素2，元素3]， 需要重新排序的原数组，
            数组名2 = [];                    临时变量，存需要交换顺序的元素，

            每次选出一个索引为i的数，
            for (var i = 0; i < 数组名1.length - 1; i++) {
                j = i + 1表示索引为i的数 所在位置 的后面的数 的索引号，每轮i数要与整个数组索引为j的数比较，
                for (var j = i + 1; j < 数组名.length; j++) {
                    if (数组名1[i] > 数组名1[j]) {
                        按排序规则交换变量数组名1[i]和数组名1[j]的值，实现选择排序。
                    }
                }
            }
    像打擂台，比如4个人比赛，选一个人和所有的人进行比较，得到一个第一名，再将剩下的3人选出一个人，与剩下的其它人进行比较，得到一个第二名，剩余2人进行比较，得到一个第三名，最后剩的1人，不用再比较，是最后一名。

函数：
    什么是函数？
        函数就是封装了一段可以被重复执行调用的代码块。
        函数可以带参数，也可以不带参数。
        函数的多个参数之间用,隔开。
    函数的目的：
        提高代码的复用率，让封装好的一段代码被多个程序使用。
    函数的封装：
        是把实现一个或多个功能的代码块，通过函数的方式封装起来，对外只提供一个简单的函数接口，类似快递打包。

    声明的函数可以分为3种形态：
        1.无参数，无返回值；
            确定的参数值，只要求实现函数的功能，不需要拿函数运行结果再进行什么操作，可以使用这种形态声明。
            例如：
                function print() {
                    document.write('hello');
                }
                print();  我需要输出一个hello时能用此函数，这里调用会输出一个hello，
                无参数：
                    输出个数在函数内部写死了，想调用一次函数输出5个hello时，此函数无法做到，因为调用一次它只能输出一个hello，不能输出多个，
                无返回值：
                    函数的执行结果在函数内部写死了，如果想输出hi，需要改函数内部的函数体。

        2.有参数，无返回值；
             不确定参数值的取值范围，只要求实现函数的功能，不需要对函数的执行结果进行操作，可以使用这种形态声明。
            例如：
               function print(n) {
                   for (var i = 0; i < n; i++) {
                        document.write('hello');
                    }
                }
                print(2);  我需要输出hello时能用此函数，这里调用会输出调用时传的参数个hello，
                有参数：
                    让此函数能想输出多少个就输出多少个hello，只要实参写想输出的个数就行，
                无返回值：
                    函数的执行结果在函数内部写死了，如果想输出hi，需要改函数内部的函数体。
                    而且只能在页面上输出，不能在控制台或弹窗里输出。 

        3，有参数，有返回值；分两种：
            有形参，有返回值：
                不确定参数值的取值范围，但能确定参数个数，并且需要对函数的执行结果进行操作，可以使用这种形态声明。
                例如：
                    function print(n1, n2) {
                        return n1 + n2;
                    }
                    print(2, 3, 4));  这里传了三个实参，比形参多一个，所以多的实参4不会被相加，得到的和是错误的。
                    有参数：
                        此函数只声明了两个参数，所以只能计算 两个数相加的和，
                        三个、四个...多个数相加时无法用此函数得到正确的和，
                    有返回值：
                        可以对函数的执行结果进行操作了，
                        将函数执行结果用console.log(print(2, 3))输出在控制台，
                        或者用alert（print(2, 3)）弹出警示框，
                        或者用document.write(print(2, 3))输出在页面上，都可以。
                               
            无形参，有返回值；
                不确定参数的取值范围，也不确定参数的个数，又要对函数的执行结果进行操作，可以使用这种形态声明。
                既可以传多个参数，又可以对函数的执行结果进行操作，想要得到传入的参数，可以通过函数的内置伪数组arguments获得，arguments是系统自动生成来存函数所有的实参的。
                例如：
                    function print() {
                        return arguments;
                    }
                    print(1, 2, 3, 4, 5....n个参数都行);
                    

    函数使用分为两步：
        1.声明函数，两种：
        第一种命名函数，语法：
            function 函数名(形参1,形参2,形参...) {
                函数体代码;
                return 执行结果;
            }

            function(函数的意思)，是声明函数的关键字，必需小写。
            函数名：
                函数名后面必需跟英文的()
                通常命名为动词，因为函数是为了实现某个功能才定义的。
                例如getSum()表示求和。
            
            返回值：
                只要是函数都有返回值，
                如果有return，就返回return后面的值，
                如果函数没有写return，就返回undefined。
                
                return 两个作用：
                    1.返回值，将函数的执行结果返回给调用方。
                    一个return只能返回一个值，
                    如果return多个值，以最后一个值作为返回值。
                    如果想返回多个值，可以将return返回值写成数组类型，将多个值作为数组的元素。

                    2.终止函数，return后面的代码不会被执行，所以return写在函数体最后面。
            
        第二种函数表达式（匿名函数）语法：
            var 变量名 = function(形参...) {
                函数体;
                return 返回值;
            }
        调用函数：变量名(实参...);
            注意：
                这里调用的是变量名()，不是函数名()，
                一定要在表达式的下面调用变量名(),否则报错，
                可以在变量名后面的小括号里传参数，和函数一样的用法，
                用函数表达式声明的函数没有函数名，所以叫匿名函数。

        函数不调用不会直接执行的,只有调用函数才会执行函数内的函数体代码。

        2.调用函数，语法：
            直接调用：
                函数名(实参1,实参2,实参...);  
                   会在控制台输出函数的运算结果，也就是返回值。

            有调用方：
                调用方变量 = 函数名(实参1,实参2,实参...);

    函数参数：
        函数参数的作用：
                在函数内部某些值不能固定，可以通过参数在调用函数时传递不同的值进去。
                有形参、实参、内置对象arguments三种。

            形参：
                形式化的参数，默认值是undefined，
                可以写多个，
                是声明函数时写在函数名的()里的参数，
                主要是占位用的，为了在调用函数时接收实参的，来实现函数的运算功能。

            实参：
                实际的参数，将形参实例化，传入具体的值，
                按声明函数时的参数数量来传入实参的数量。
                传参：
                    将实参赋值给形参。
            
            arguments对象：
                arguments对象是函数的内置对象，展示形式是一个伪数组，也是用[]包裹数据，
                具有数组的length属性，
                和数组一样按索引方式存储数据，
                不能使用数组的push、pop等方法。

                作用：
                    是每个函数的一个内置对象，接收并储存函数所有的实参。
                使用场景：
                    当不能确定函数会传多少个实参，
                    声明函数时就无法确定写多少个形参占位，
                    此时可以不给函数写形参，
                    用arguments对象获取用户传入的所有参数，
                    再像操作数组一样操作arguments对象。

        形参和实参个数匹配问题，三种情况：
            1.实参等于形参个数，程序会正常执行运算。
            2.实参比形参多，程序不会报错，会只取到形参的个数为止，多余的实参不执行。
            3.实参比形参少，程序不会报错，少的形参个数都会直接定义为默认值undefined，最后程序运行结果是NaN。

内存管理机制（垃圾回收机制）：
    函数内部声明的变量和形参是属于当前函数的内存空间里的，会随着函数的调用被创建，随着函数的调用结束而被销毁。
    任何程序在执行的时候都要占用内存空间，函数在调用的时候也要去占用内存空间，
    当函数被调用的时候，系统会分配对应的空间给这个函数使用（空间大小一般由这个函数里声明的变量和形参决定）当函数执行结束后，这个调用时分配的内存空间就要释放（销毁），还给系统。

递归：
    满足以下三个特点的就是递归：
        1.函数自己调用自己
        2.一般情况下有参数
        3.一般情况下有return
    作用：
        递归可以解决循环能做的所有事情，有一些循环不容易解决的事情，递归也能轻松解决。
    写递归的方法：
        1.首先找临界值，就是无需计算，根据题目就能获得的值（作为停止递归的条件）
        2.找题目里这一次和上一次的关系，也就是规律
        3.假设当前函数已经可以使用，调用自身计算上一次。
    递归在内存管理里的表现：
        递归调用自己多少次，就需要开辟多少个内存空间，直到整个函数执行结束，才能销毁，特别占内存资源，工作中公司都禁止使用递归函数。
        根据内存管理机制可以知道，函数在调用时需要分配内存空间给函数，函数执行完系统才会销毁分配给这个函数内存空间，
        例如：
        计算1-4相加的和：
        function sum(n) {
            这是临界值，也就是让递归停止的条件，是不需要计算或口算就能获得的，只要n不等于1就要执行if之外的代码。
            if (n == 1) {
                从1开始的，所以1没有数可以和它相加，得到的和仍然是1
                return 1;
            }
            这是if之外的代码，函数自己调用自己，函数要调用自己直到n==1次，才满足if控制的条件，停止调用自己，
            return sum(n - 1) + n;
        }
        如果n是4时：
            递归第一层（第一次调用函数，外面的调用方调用的）：
                前面3个数相加的和+4才是结果，但前面3个数相加的和不知道，又分配一块内存空间去计算前面3个数相加的和（也就是继续执行调用自己的那句代码），
            递归第二层（第二次调用函数，自己调用自己）：
                前面3个数的和是前面2个数的和加起来+3得到的，又要去先得到前面2个数的和，
            递归第三层（第三次调用函数，自己调用自己）：
                前面2个数的和是前面1个数+2得到的，需要知道前面1个数是多少，
                这时已经调用了4次函数，开辟了4个内存空间，而且4个函数都还没有得到结果，没有执行结束，4个内存空间都占用着没销毁。
                如果是个上亿的数，就会开辟上亿个内存空间占着，在没计算出结果之前都没有销毁，特别耗内存资源，可能会导致电脑卡死等问题，
            递归第四层（第四次调用函数，自己调用自己）：
                得到n==1,满足if语句，得到临界值前面那1个数，是返回值1，停止递归，
                再将1带入，计算它们每层相加的结果，得出一层结果销毁一个调用函数开辟的内存空间。
            


作用域：
    作用域是什么？
        就是代码的名字（变量）在某个范围内起作用和效果。
    目的：
        为了提高程序的可靠性、减少命名冲突；

    es6之前作用域分两种：
        全局作用域：
            作用区域是整个script或js文件，程序都能通过名字调用它；
            也就是当前这个js文件或script标签里能用，这个js文件或script标签外面就不行。
            有点像身份证，全中国能中，出国就不行。
            
        局部作用域：
            也叫函数作用域，
            在函数中声明的变量和形参，有效范围是当前函数（当前这个函数的大括号内），
            在函数内部的就是局部作用域，这个代码的名字只在函数内部起作用，
            函数外的程序是无法通过名字调用它的，否则会报未定义的错误。
            有点像校园卡，只在这个学校里能用，出了学校门就不行。

    变量的作用域：
        全局变量：
            在全局作用域下声明的变量叫全局变量（在函数外部定义的变量），
            全局变量在代码的任何位置都能通过变量名来调用、使用，
            执行效率：
                只有在浏览器关闭的时候才会销毁，比较占内存资源。
            有两种：
                第一种：
                    声明在script标签或js文件里的变量叫全局变量；
                第二种：
                    写在函数内部未用var声明，直接赋值的变量，也是全局变量（不建议使用，因为属于语法错误）；

        局部变量：
            在局部作用域下声明的变量，也就是在函数内部声明的变量叫局部变量；
            函数的形参也可以看做是局部变量；
            只能在函数内部使用，函数外的程序无法通过名字调用使用它，否则报错；
            执行效率：
                当函数执行时，才会执行，
                当这个函数程序执行完毕，就会销毁，比较节约内存资源。
        
作用域链：
    内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结果称作作用域链；
    例如：
        函数嵌套时，最里层的函数会采用就近原则，一层层向外查找变量，就是作用域，
        直到找到才会执行结果，
        如果找不到就报错变量未被定义。


js预解析：
    js引擎运行js分为两步：
        预解析（预编译）：
            代码在运行之前，计算机（js引擎）将代码从头到尾看一遍，然后将这个程序需要运行的内存空间一次性分配好，就不能再改变；
            也就是，计算机会将js文件里面所有的var和function提升到当前作用域的最前面（最上面一层）声明，分配好空间，再运行程序代码；
        预解析分两种：
            变量预解析（变量提升）：
                把所有的变量声明提升到当前作用域的最前面，但不提升赋值操作；

            函数预解析（函数提升）：
                把所有函数的声明提升到当前作用域的最前面，但不调用函数。
                所以调用函数时函数名写在函数上面或下面位置都能正常执行，不会报错；
                但函数表达式（匿名函数）必需在表达式下面位置调用变量名，否则报错。
        代码执行：
            按照书写顺序从上往下执行。

    
js对象（object）：
    什么是对象？
        在js中，对象是一组无序的相关属性和方法的集合，万物皆对象；
        对象指的是一个具体的事物；
        对象是用{}表示的；
        是复杂的数据类型。
    作用：
        可以让代码结构更清晰。

    对象是由属性和方法构成的：
        属性：
            事物的特征，常用名词命名。
        方法：
            事物的行为，常用动词命名。
    
    创建对象的3种方式：
        1.利用字面量创建对象，相当于python的字典，语法：
            用var声明，用{}包裹属性和方法等代码体，代码体都采用键值对的方式书写，值可以是任何数据类型，用,结尾：
                var 对象名 = {
                    属性名:值,
                    方法名:function() {
                        函数体代码....
                    },
                };

        2.利用new Object()创建对象,语法：
            用var声明，先创建一个空对象,O一定要大写，用;结尾：
            再创建对象的属性，用赋值的方式，用;结尾：
            或再创建对象的方法，方法名后面跟的是匿名函数：

                var 对象名 = new Object();
                对象名.属性名 = 属性值;
                对象名.方法名 = function() {
                    匿名函数体代码...;
                };


        3.利用构造函数来创建对象：
            
            什么是构造函数？
                构造函数是指某一类事物，相当于python的类，相当于数学中的公式，是抽象的；
                是把对象的一些相同的属性或方法抽象出来封装到函数里，这个函数就称为构造函数，
                这个函数里封装的不是普通代码，是对象；
                
                例如：
                    这个苹果，明星王一博等都是对象；
                    苹果、明星都是构造函数。

            构造函数语法：
                function 构造函数名(形参1,形参2....) {
                    this.属性名1 = 值1（这里的值指的是构造函数的形参）;
                    this.属性名2 = 形参2;
                    this.方法名 = function(形参...) {
                        匿名函数的函数体代码...;
                    };
                }

                注意：
                    1.构造函数名的首字母一定要大写；
                    2.构造函数不需要写return就可以返回结果；
                    3.调用构造函数必需使用new；
                    4.构造函数内部的属性和方法前面必需加this.开头，以;结尾。

            构造函数创建对象，语法：
                var 对象名 = new 构造函数名(实参1,实参2....);

                创建对象的方法，在这里传入方法的实参
                    对象名.方法名(方法的实参...);

                注意：
                    用构造函数创建对象也叫对象的实例化；
                    创建对象的构造函数的括号里传的是实参，也就是将属性的属性值实例化；

            new在执行时会做4件事情：
                1.在内存中创建一个空的对象；
                2.让this指向这个内存中新创建的对象；
                3.执行构造函数里的代码，给这个新创建的对象添加构造函数里的属性和方法。
                4.构造函数执行完后，返回这个新创建的对象，所以构造函数里不需要写return。

            this变量:   
                只要封装函数,任何一个函数系统都会内置一个叫this的变量;
                this变量存储的是地址,是当前函数主人的地址;
                this指向，永远指向当前函数的主人,谁调用function匿名函数，this就指向谁。
                function 函数名() {}; 这种函数直接是function开始的,看起来没有主人,实际上因为所有内容都归属window,所以它的主人是window;
                var 对象名 = {方法名.function(){} }; 对象内部的方法,的主人是这个对象;
        
    对象的调用，如下：
        调用对象的属性，两种：
            第一种，语法：
                对象名.属性名;

            第二种,语法：
                对象名['属性名'];
        
        调用对象的方法,语法：
            对象名.方法名();

        注意：
            1.这个 . 可以理解为 的 ；
            2.第二种调用属性的方式[]里的属性名一定要用''引起来；
            3.调用对象的方法一定要在方法名后面加(),因为方法是个匿名函数。

    使用for...in...快速遍历对象或数组，
        因为不需要判断是否符合循环执行条件，直接遍历，所以效率比for循环高，安全性比for循环差；
    语法：
        数组：
            for (存元素的变量名 in 数组名) {
                console.log(数组名[存元素的变量名])
            }
        对象,只有这一种遍历方法：
            for (key in 对象名) {
                
                得到key的写法：
                console.log(key);

                得到键的值的写法：
                console.log(对象名[key]);
            }



变量和属性、函数和方法的区别：

    变量和属性相同之处：
        变量和属性都是存储数据的。
    不同：
        变量是单独存在的，单独声明的，使用的时候直接写变量名；
        属性是在写在对象里面的，不需要声明，使用的时候必需对象.属性;

    函数和方法相同之处：
        函数和方法都是实现某种功能的。
    不同：
        函数是单独存在的，单独声明的，使用的时候直接调用函数名();
        方法是写在对象里面的，是匿名函数的写法，调用的时候必需对象.方法();


正则表达式(regular expression):
    简称RegExp,是一个描述字符模式的对象,是由一个字符序列形成的搜索模式。
    字符模式是一组特殊格式的字符串，它由一系列特殊字符和普通字符构成，其中每个特殊字符都包含一定的语义和功能。

    功能:
        模式匹配(要么匹配字符，要么匹配位置)/文本检索/替换;

    声明正则表达式,3种:
        通过new操作符:
            var re = new RegExp('正则表达式的主体字符串', '修饰符');
                RegExp是构造函数,创建正则表达式对象的;
                参数只接受字符串类型,2个:
                    参数一:正则表达式的主体,也就是需要匹配的内容,
                        如果参数里含一个\,任何\都表示字符本身,需要再加一个\让主体字符转义,变成字符模式;
                    参数二:修饰符;
                返回值: 
                    创建好的正则对象;
                
        省略new操作符:
            var re = RegExp('正则表达式的主体字符串', '修饰符');
                返回值: 
                    创建好的正则对象;
                    
        字面量:
            var re = /正则表达式的主体字符串/修饰符;
                返回值: 
                    创建好的正则对象;

    JS正则表达式的结构:
        字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。
    优先级,优先顺序是从上到下 、从左到右依次降低:
        \	转义符
        (), (?:), (?=), []	圆括号和方括号
        *, +, ?, {n}, {n,}, {n,m}	限定符
        ^, $, \任何元字符、任何普通字符	
        |

    元字符,是在正则表达式中有特殊含义的字符:
    元字符作用汇总:
        分组的 ()
        匹配特定字符的 .  []  |
        匹配重复次数的 *  +  ?  {} {m,n}
        匹配位置的 \b  \B  ^   $   \A  \Z 
        匹配数字、数字与字母的 \d  \D  \w  \W \S
        匹配空白元字符的 \f  \n  \r  \t  \v  \s 
        匹配大小写的 \l、\L、\u、\U、\E还没验证过，不知道写的对不对;

    每个元字符的作用: 
        匹配位置的:   
            ^    匹配字符串的开头,在多行匹配中匹配行开头。
            $	 匹配字符串的末尾,在多行匹配中匹配行结尾。
            ^ $  开头和末尾位置的元字符同时出现时，中间的部分必需匹配整个目标字符串的全部内容;
            \A   匹配字符串开始;
            \Z   匹配字符串结束，末尾字符写在\Z前面，如果是存在换行，只匹配到换行前的结束字符串。
            \b	 匹配单词边界,也就是指单词和其它字符间的位置,
                    具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。
            \B	 匹配非单词边界;

            可以把这4种环视理解成看看右边或看看左边,位置可以理解成每个字符之间有看不见的空字符;
                (?=)  肯定顺序环视，向左预查,匹配表达式目标字符串的前面的那一个位置。
                            例如:'hello'.replace(/(?=e)/g, #); 将hello的字母e前面的一个位置替换成#,结果是:'h#ello';
                (?!)  否定顺序环视，与向左预查相反,除了目标字符串前面的一个位置,其它位置都匹配；
                            例如:'hello'.replace(/(?!e)/g, #); 将hello除了字母e前面的一个位置,其它位置都替换成#,结果是:'#he#l#l#o#';
                (?<=) 肯定逆序环视,匹配表达式目标字符串后面的那一个位置;
                            例如:'hello'.replace(/(?<=e)/g, #); 将hello的字母e后面的一个位置替换成#,结果是:'he#llo';
                (?<!) 否定逆序环视,与向右预查相反,除目标字符串后面的那一个位置,其它位置都匹配;
                            例如:'hello'.replace(/(?<!e)/g, #); 将hello除了字母e后面的一个位置,其它位置都替换成#,结果是:'#h#el#l#o#';

        匹配单个数字或字符的:
            .	    查找单个字符，等价于[^\n\r\u2028\u2029],
                        通配符，表示换行符、回车符、行分隔符和段分隔符除外的任意字符。
                        记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。
            [ ]     字符集,表示范围,匹配[]里任意的字符,
                        只要字符串中含有字符集里的字符，都会被匹配到;
                        中文的范围[\u4e00-\u9fa5];
            [^...]  不在[]中的字符,中括号里第一位^（脱字符），表示求反的概念。
                    例如：[^abc] 匹配除了a,b,c之外的字符。
            
            \w	    查找单词字符,等价于[0-9a-zA-Z_],表示数字、大小写字母和下划线。
                        记忆方式：w是word的简写，也称单词字符;
            [a-z]   匹配小写字母，[A-Z]匹配大写字母。(连字符 - 来省略和简写,表示范围) 
                        相比之下\w更好用;
                    
                    因为连字符有特殊用途，那么要匹配“a”、“-”、“z”这三者中任意一个字符,可以写成如下的方式：
                        [-az]或[az-]或[a\-z]。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。


            \W	    查找非单词字符,等价于[^0-9a-zA-Z_],表示不能是数字、大小写字母和下划线;

            \d	    查找一位数字,等价于[0-9],记忆方式：其英文是digit（数字）。
            [0-9]   匹配数字。相比之下\d更好用;

            \D	    查找非数字字符,等价于[^0-9];
        
        匹配多个重复字符或数字的:
            *    匹配0个或多个的表达式,等价于{0,}，表示出现任意次，有可能不出现。
                    记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。
                    因为*前面的字符是0次也可以，0次返回空字符，所以返回结果里会有很多空字符;
                    .*组合是泛匹配(贪婪匹配),会尽可能多的匹配;
            ?    匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式;
                    等价于{0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？
                    .*?组合是惰性匹配(量词后面加个?就是非贪婪匹配),会尽可能少的匹配;
            +    匹配1个或多个的表达式,等价于{1,}
                    记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。
            {m}  精确匹配 m 个 花括号前面的表达式。花括号里的可以理解为长度或次数;
                    例如： /o{2}/ 不能匹配 "Bob" 中的1个 "o"，能成功匹配 "food" 中的2个 o。

            { ,} 花括号里只填逗号，逗号前面的数字默认为0,这样匹配结果会产生很多空字符;
            {m,} 逗号前面数字填几，花括号左边的字符就至少重复几次。
                        例如， /o{2,}/ 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。
                        /o{1,}/ 等价于 /o+/。
                        /o{,}/或/o{0,}/ 则等价于 /o*/。

            { n, m} m 和 n 均为非负整数，其中n <= m。
                        最少匹配 n 次且最多匹配 m 次。注意在逗号和两个数之间不能有空格，贪婪方式;

            |    或关系，优先级比其它字符低，排最后;
                    目标字符串里只要有一个满足, | 左边和右边的表达式就匹配成功,返回第一个满足的,后面的就不再进行匹配了;
                        例如:用/good|goodbye/，去匹配"goodbye"字符串时，结果是"good";
                    全局模式下,如果 左边|右边 表达式在目标字符串里都含有，那就会全部获取到;
                        例如:用/good|nice/，去匹配"goodbye nice"字符串时，结果是"good nice"

            ()   对正则表达式分组,括号里是要匹配到的匹配目标,看做一个整体;
                    例如: /(abc)/,意思是含abc这个整体的才能成功匹配,只含有a或b或c都不行;
                    可以使用方法返回值的索引号,或构造函数的全局属性$1至$9来获取组里的数据;
                    例如:RegExp.$1是获取正则表达式的第一个分组;
            ()+  匹配一个或多个组匹配目标;
            (?:) 非捕获组,因为小括号表示分组,所以(?:)来表示不是一个组,只表示小括号,
                        用来提高括号里匹配目标的优先级的;
                        例如: 写成(?:a|b)\. 意思是a|b\. 但b和\.不是一部分;
                        这里括号不表示一个组，只是把或符号优先运算了;

            (?P<name>pattern) 捕获组。
                给子组取个名字来表达该子组的意义，有名字的子组叫捕获组，
                一个正则表达式中可以包含多个子组
                子组可以嵌套，但不要重叠或者嵌套结构复杂
                子组序列号一般从外到内，从左到右计数

            反向引用,是正则引用自身的分组:必需一个正则表达式里前半部分有分组,后半部分直接通过\1\2引用,\1表示引用第一个分组,\2表示引用第二个分组...以此类推;
                    例如:/(\d){2}\1/g;其中(\d)表示组里面是数字,{2}两位数字,\1引用组,g全局;
                引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如\2，就匹配"\2"而不是匹配2。

        空白字符的:
            \s	    查找任意空白字符,等价于[ \t\v\n\r\f]。
                        表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。
                        记忆方式：s是space character的首字母。

            \S	    查找非空白字符,等价于[^ \t\v\n\r\f];

            \0	    查找 NUL字符;
            \n	    查找换行符;
            \f	    查找换页符,也是进纸字符(打印机打完一页,吸进一张纸继续打印,就是通过\f实现的);
            \r	    查找回车符;
            \t	    查找制表符;
            \v	    查找垂直制表符;


        \xxx	查找以八进制数 xxxx 规定的字符
        \xdd	查找以十六进制数 dd 规定的字符
        \uxxxx	查找以十六进制 xxxx规定的 Unicode 字符
        

    修饰符:
        i	代表忽略大小写
        g	代表全局匹配
        m	执行多行匹配






  
                    
                    
                    



    


        



    
                      



        








        

    

        




    





