promise是什么?
    promise是ECMA6的新语法,是一个(构造函数)对象,专用于处理异步编程的,将异步请求和处理请求结果的回调函数分开写,请求写在promise实例里,处理结果的代码写在then()里,让代码可读性更高,好维护;
    也能将异步操作序列化,按照我们想要的顺序执行,返回符合预期的异步执行结果,主要作用是更优雅的写异步请求的回调函数,解决回调地狱的问题;
    回调地狱是什么?
        异步请求时,正常情况下多个请求会同时各自执行,互不影响,谁执行的快,先执行完谁就先返回结果,并不一定是按写请求时的顺序先写谁,谁就先返回结果的;
        如果对异步请求的结果有依赖的请求,就必通过回调函数的嵌套,保证每个异步任务的执行顺序,
        例如:
            第二个请求要用到第一个请求返回的结果,就必需将第二个请求写在第一个请求的回调函数里,才能先执行第一个请求的回调函数,将结果传给第二个请求,再执行第二个请求,这种有顺序的执行,就会产生函数嵌套,
            如果第三个请求要用第二个请求的返回值,那第三个请求就必需写在第二个请求的回调函数里,以此类推,会产生多层函数嵌套,这样的代码就是回调地狱,可读性差,维护难,
        promise是将函数嵌套的回调地狱写法变成链式调用的写法,第二个请求要使用第一个请求的结果,那就将第二个请求写在.then()的参数函数里,在then()里再创建一个promise实例,在实例里写第二个请求,解决函数嵌套问题,例如:
            第一个请求的promise实例对象.then(第一个请求成功的数据=>{
                处理数据的代码;
                return 第二个请求的promise实例对象;
            })       
            .then(第二个请求成功的数据=>{ //这个then()是被上面的return的实例对象,也就是第二个请求的结果调用的
                处理第二个请求数据的代码;
                return 第三个请求的promise实例对象;
            })
            .then(第三个请求成功的数据=>{ //这个then()是被第三个请求结果调用的
                处理第三个请求数据的代码;
            })


promise语法:
    //创建一个promise实例对象,对象有一个参数,是函数类型
    var 变量1 = new Promise(function(resolve,reject){ //函数有2个参数,2个参数也是函数,名字是固定写法;
    //异步请求写在promise实例里:
        异步请求(url,请求里写的回调函数{
            if(请求成功的数据){
                resolve(请求到的数据); //请求成功时执行这个参数函数
            }else(请求失败信息){
                reject(失败的信息); //请求失败时执行这个参数函数
            }
        });
    })

    请求成功后,处理请求结果的代码写在then()里:
        变量1.then(function(请求成功时通过resolve()函数传过来的数据){ 
            处理成功数据的代码..;
        }).catch(function(请求失败时通过reject()传过来的信息){ //catch()
            //请求失败后,返回的错误信息在catch()里处理;
            处理失败信息的代码..;
        })

    或者写成then()里传2个参数,2个参数都是函数:
        变量1.then(function(请求成功时通过resolve()函数传过来的数据){
             处理成功数据的代码..;
        }, function(请求失败时通过reject()传过来的信息){
             处理失败信息的代码..;
        })
        
    注意:
        1.then()里写1个参数时,要和catch()一起使用,then()接收resolve()的返回值,catch()接收reject的返回值;
        2.then()里传2个参数时,第一个参数接收resolve()的返回值,第二个参数接收reject的返回值;
        3.promise实例对象可以赋值给变量,再通过变量调用then()等方法,也可以不赋值,直接在实例后面调用then()等方法;

    then()函数的返回值有2种:
        1.return一个promise实例对象,来调用下一个then(),有2种写法:
            如果继续异步请求,就return一个promise实例对象:
                return new Promise((resolve,reject)=>{
                    resolve(data);
                });
            如果是对上一个异步请求的结果进行处理,可以省略new个实例对象,直接调用resolve()方法,将上一个请求结果传给下一个then(),简写成:
                return Promise.resolve(请求成功获得的数据);
                或者把Promise.resolve()也省略不写,直接return 上一个异步请求的结果:
                    return 请求成功获得的数据;
                如果请求失败,也可以简写成:
                    return Promise.reject(请求失败的信息);

        2.return一个普通的值,系统会默认产生一个新的promise实例对象调用下一个then(),then()的参数函数的参数会接收这个普通值;


promise实例对象的常用方法:
    也就是定义在prototype原型上的方法,给构造函数的实例调用,参数都是一个函数;
    实例对象.then() 获取异步请求成功的结果,接收resolve()传过来的数据
    实例对象.catch() 获取异步请求失败的结果,接收reject()传过来的信息
    实例对象.finally() 异步请求成功或失败都会执行,可以用来写提示信息,销毁一些资源等


promise对象的常用方法:
    也就是定义在构造函数上的方法,只能构造函数自己调用,参数都是可迭代对象,一般都传数组,数组里的元素是异步请求任务;
    Promise.all() 并发处理多个异步任务(也就是同时发送多个异步请求),所有任务都执行完成才会返回结果,执行顺序按照数组里传的任务的顺序来执行;
        返回值:
            全部请求成功时返回一个数组,数组元素是每个异步请求的执行结果,这个数组的元素顺序和all里传的数组元素的顺序一一对应的;
            有请求失败的就返回最先失败的那个请求执行的reject()传过来的信息;
    Promise.race() 并发处理多个异步任务,只要有一个任务执行完成,就会返回结果;
        返回值:
            返回最快执行完成的那个异步请求的结果,不管请求成功还是失败;
        例如:
            Promise.race([异步请求1,异步请求2,异步请求3]).then(result) => {
                console.log(result) //这里输出的是最快执行完的那个请求的结果
            })
        