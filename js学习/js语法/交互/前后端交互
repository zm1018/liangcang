注意:
    vue和axios和实现AMD规范的库require.js文件等等..都是第三方框架,用第三方框架时,不要项目的每个文件里都引入此文件,要把第三方框架封装在一个自己创建的文件里,其它所有文件都引入这个自己创建封装的文件,以后如果第三方框架不维护了或淘汰不能用了就不用每个文件都改,只用改自己封装的那个文件就行了

前后端交互流程:
    1. 通过ajax或promise或fetch或axios发送请求,传数据到后台,或从后台下载数据;
    2.分析下载到的数据,转成对应数据结构;
    3.处理转换后的数据;
    
ajax 是异步的 javaScript 和 数据传输(xml),没有promise好用,promise是EMAS6里的新语法,基于promise的fetch方法发送请求更简单好用,axios也是基于promise的,是第三方封装的专门做网络请求的框架,要下载个axios.js文件,比fetch更强大,也好用推荐用;
理解异步请求:
    它将前台的数据传输到后台,将后台的数据返回到前台,数据传输可以同时进行,互不影响;
    在不重新加载页面的情况下更新网页;
    在页面已加载后从服务器请求数据;
    在页面已加载后从服务器接收数据;
    在后台向服务器发送数据;
    就像人搬东西,左手拿前台数据,右手拿后台数据,互不影响, 而不是一次只拿前台数据,搬完下一趟再去搬后台数据;

    任何一个程序都是由很多段代码组成的,这很多段代码就是很多个小程序;
        同步: 就是阻塞,得前一个小程序先运行完,后一个才能运行; open方法里写false,同步
        异步: 就是可以同时运行,互不影响,各执行各的; open方法里写true(默认值)是异步

数据传输:
    数据传输就像买的整套家具,运输时需要拆分装车,运回家又需要组装起来,家具不是随便拆的,需要按结构组成去拆,数据也是,json像随家具附送的家具组装说明书;
    数据在前端和后端都是通过数据结构(数组/对象)存储,传输时需要拆分,转成2进制传输,二进制传输最有效的方式是字符串,所以数据传输都是通过字符串传输,2种字符串传输格式,xml和json:
        xml(像html的写法):
            通过用户自定义的标签,把数据放在标签的内容里,来传输数据;
            优点:
                1.数据种类丰富,都是用户自定义的,标签名可以写任何单词,数据可以写任何内容;
                2.传输数据量非常大,标签可以重复出现,无限写下去;
            缺点:
                1.解析麻烦,
                2.不太适合轻量级数据;

        json(字符串类型,像数组和对象的写法,不是普通字符串,是json格式的字符串),95%的移动端应用都是json格式:
            优点:
                1.轻量级数据
                2.解析比较轻松
            缺点:
                1.数据种类较少, 比如: 美团,数据种类大都是 图片/名称/价格/销量/评论 这几种;
                2.传输量较小;

            json对象转换方法:
                数据结构转字符串:
                    前端: JSON.stringify(数组/字符串);
                    后端: json_encode();
                字符串转数据结构:
                    前端: JSON.parse(json格式的字符串);
                    后端: json_decode()

实现ajax请求:
    1.创建ajax对象:
        var 变量 = new XMLHttpRequest();            //相当于打开浏览器页面
        IE8以下兼容的写法,2种:
            第一种:
                var xml = null;
                if(window.XMLHttpRequest) {
                    xml = new window.XMLHttpRequest();
                } else{
                    xml = new ActiveXObject('Microsoft.XMLHTTP');
                }
            第二种:
                try{
                    var xml = new XMLHttpRequest();
                }catch(error){
                    var xml = new ActiveXObject('Microsoft.XMLHTTP');
                }
        这个对象能发发送的远不止Xml文本(而且发送Xml其实很少使用)
        这个对象也不是只能使用Http, 它还能用于Https或者其它网络通信协议
        这个对象也不是Request, 它还负责Response;
    2.调用open()方法创建请求的基本配置,用什么方法请求,请求哪里的数据,同步还是异步执行等:
        变量.open("请求方式","url",true);            //相当于在浏览器的地址栏输入url
            参数1:请求方式;
            参数2:文件路径;
            参数3: true异步(默认值),false同步; 
                true异步时,不用等待服务器返回send()方法的执行结果,就可以执行后面的其它代码;
                false同步时,要等待服务器返回send()方法的执行结果,当等待返回结果超时不再等待了,或拿到返回结果后,才执行后面的代码;
    3.调用send()发送请求:                            //相当于按enter键
        变量.send();
            如果是post方法,send()里必需写不带?的查询字符串(也就是要发给服务器的数据)做参数,将数据发送给服务器;
            同步的时候，send方法要接收到服务器返回的数据后才返回。
            异步的时候，send调用后立即返回，服务器返回的数据在onreadystatechange设置的异步回调函数里面进行读取。
    4.使用onreadystatechange事件类型,等待数据响应:    //相当于按完enter键后加载网页时转圈
        变量.onreadystatechange=function(){};
            当readyState值是2时,会触发这个事件,执行后面绑定的函数;
            后续的每次readyState属性值变化,都会触发这个事件;

        readyState属性,是请求状态,在状态发生变化的时候调用,有5个值:
            0   (初始化)XMLHttpRequest对象已创建或已被 abort() 方法重置,并为调用open()方法进行未初始化作好准备;
            1   (载入)表示正在向服务端发送请求,已调用open()方法，根据参数(method,url,true)完成xml对象状态的设置。并调用send()方法开始向服务端发送请求。
            2   (载入完成)send方法调用完成,已经接收到所有的响应内容,并为下一阶段的数据解析做准备,此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。
            3   (解析)此阶段正在解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。
            4   (解析完成)此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成,可以在客户端调用了, 并且断开前后端的请求连接;
            所以往页面显示数据时,都要判断一下,在值==4的时候再输出下载到的数据;

        status属性,(服务器的状态),是请求下载的这个资源的状态码, ==200的时候是下载成功,都要在readyState==4的时候才能接收到这个响应;  
            怎么理解服务器的状态: 
                类似你客户端来拿我服务器的东西,我理不理你,让不让你拿,拒绝或者同意都要给你个态度回应你;
        responseText属性,是响应文本,存的是下载成功要输出给用户看的数据,以文本的形式返回给用户,如果readyState状态码值小于3,返回空字符串;
        responseXML属性,以XML的形式返回给用户;

    xml实例对象还有很多方法,要用的时候再去百度吧,除了上面的open()和send():
        abort()
            取消当前响应，关闭连接并且结束任何未决的网络活动,单词是终止计划的意思。
            这个方法把 XMLHttpRequest 对象重置为 readyState 为 0 的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。

XMLHttpRequest创建实例对象时,兼容写法用try..catch 或 try..throw..catch 进行判断比if..else执行效率高, 让代码更强壮,在新增代码时将新增的代码放到try里面执行,可以迅速捕获异常,常用来代码调试和后期维护:
    try{
        尝试执行的代码,如果执行正常,catch中的代码就不执行了;
    }catch(error){
        error 是错误对象,这里输出的是try中的代码执行报错的信息;
        补救代码,try报错时执行这里的代码;
    }
或:
    try{
        尝试执行的代码,如果执行正常,catch中的代码就不执行了;
        throw new Error('错误提示信息');  
        这个throw是手动抛出异常,是程序员故意设置的错误信息,try执行到这行代码,就会停止执行throw下面的,直接去执行catch里的代码, new Error是创建错误对象;
    }catch(error){
        error 错误对象,这里输出的是try中的代码执行报错的信息;
        补救代码,try报错时执行这里的代码;
    }


get请求提交数据:
    数据通过查询字符串用键值对和&拼接,
    通过?将查询字符串拼接在url里,作为参数提交到后台,传给php里的全局get或post变量,数据以数组格式存储,
    再把php里调用数据的键对应的值提取出来,将要输出的内容返回到html页面,
    优点:
        传输数据简单
    缺点:
        不安全,数据都是暴露在url里可见的,
        url不能写太长,所以数据最大只能传输2kb,就无法实现图片/文件/视频等数据的上传了;

ajax实现get请求:
    将要传的参数写在open方法的第二个参数,url后面,用?拼接查询字符串;

post请求提交数据:
    通过浏览器内部进行提交,
    数据不会暴露在url里,安全,传输量大,

ajax实现post请求:
    在open()和send方法之间调用setRequestHeader()方法,设置请求头,也就是请求方式:
        setRequestHeader('content-type', 'application/x-www-form-urlencoded');
    在send方法里传入参数,是不带?的查询字符串:
        send('a=1&b=2');

查询字符串,2种:
    ?键=值&键=值   这种叫search, ajax的get请求时用;
    键=值&键=值    这种叫querystring, ajax的post请求时用;

form表单提交数据的enctype属性,3种值:
    application/x-www-form-urlencoded:
        这是表单提交的默认格式，不支持文件类型,它的请求格式是键值对;

    multipart/form-data:
        既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来说明文件类型；content-disposition，用来说明字段的一些信息；
        提交文件必须要用这种格式，它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。所以可以上传多个文件。注意不能设置'Content-Type'='multipart/form-data'. 因为你手动设置了它,那么后面这个boundary=浏览器默认boundary就没了。这个是分界线，服务端是以这个分界线去key值.如果没有分界线服务端就不知道从从哪个位置开始取key`

    text/plain:
        是以纯文本格式（就是一段字符串）发送的. 如果你发送一个对象例如{ name:"leiwuyi", age:12 }一定要对它做JSON.stringfiy()处理，否则将传送[object Object]

提交数据:
    from表单的submit提交时,发送请求,会进行页面跳转,如果提交后需要跳转到其它页面用这种;
    ajax提交数据时,发送请求,会继续停留在当前页面,如果提交数据后要继续在当前页面,用这种;

前后端交互时,往数据库插入数据,不管成功或失败,都要有一个返回,所以反馈格式最好规定好格式,模拟浏览器的反馈格式,一个状态码,一个反馈信息:
$responseData = array("code" => 0, "message" => "");

同源和跨源:
    上网浏览的网页网站都是请求下载别人服务器上的数据,这都是跨源;
    同源策略:
        1.同协议     例如:http就不能直接下载https上的数据
        2.同域名/ip  例如:localhost
        3.同端口号   
    ajax下载数据只能下载同源(同服务器上)的数据,跨源(别人的服务器上)的数据是禁止下载的,控制台会报警告,已拦截跨源请求;
        标签的src属性没有跨源问题,可以无限制跨源,可以引入任何服务器下的任何后缀的文件;
        文件后缀的作用:
            1.对于计算机来说,文件后缀没有任何作用,里面的数据都会转成0和1,所以主要是数据是不是我们想要的,和后缀无关;
            2.后缀主要是给计算机上下载的软件用,让计算机能快速识别用哪个软件打开文件;
    跨源的方式,3种:
        1.修改ajax同源协议
            不建议,ajax禁止跨源,就是为了数据安全,否则你能随便访问别人的服务器,别人也能随便访问你的服务器;
        2.反向代理转发请求,委托php文件向别人的服务器发送请求,它没有跨源问题,可以让php文件去下载数据,前端ajax再向自己服务器上的php文件发送请求,就像吃饭,不想自己去买,让外卖员送来,php文件相当于这个外卖员;
        3.JSONP跨源,必需是通过函数调用的形式下载数据:
            1.在当前要下载数据的页面专门用一个script标签,这个标签里只写这个函数声明和处理数据的代码,
                声明一个函数,函数设置一个形参,这个形参用来接收要下载的数据,在函数体里写处理数据的代码;
            2.在需要下载数据的时候,再写一个script标签(这个创建的标签插在哪里都能用),这个标签里面写动态创建script标签的代码,通过script的src属性,将需要下载的数据的url写上,并在url的查询字符串里拼接上面那个标签里 声明的函数的函数名(这里调用函数),访问的那个url上的数据将作为实参,传给我们声明的函数,这样数据就能在需要的时候下载,
                而不是直接将script标签写在head标签里,页面一加载就自动下载;
            3.当script标签插入到页面上的时候,就会通过src传的url,调用那个存数据的url里的函数,函数就会执行,进行传实参(实参是我们要下载的数据),给当前要下载数据的页面上声明的这个函数,这样就拿到我们需要下载的数据,就能成功下载数据了;
        
    
网络传输协议:
    数据在网络上传输的时候需要遵守的传输规则,就像开车要遵守的交通规则,是人为制定的;
    计算机网络:
        ISO组织规定:
            7层的网络分层
        程序员实际通用的:
            5层的网络分层:
                1.应用层  下载的各种app,例如QQ
                2.传输层   
                    TCP/UDP协议 端口号是在传输层的,经过这里会拼上一个端口号,告知数据哪个应用发的;
                    TCP面向连接协议:
                        1.建立连接,通过3次握手:
                            客户端向服务器发要下载某条数据的请求,叫做ClientHello:
                                https协议在这一步，客户端主要向服务器提供以下信息:
                                （1） 支持的协议版本，比如TLS 1.0版。
                                （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
                                （3） 支持的加密方法，比如RSA公钥加密。
                                （4） 支持的压缩方法。
                            服务端返回收到请求,准备好连接的回复,叫做SeverHello:
                                https协议在这一步,服务器的回应包含以下内容:
                                （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
                                （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
                                （3） 确认使用的加密方法，比如RSA公钥加密。
                                （4） 服务器证书。
                                除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。
                            客户端回应,返回我也准备好了,开始传输数据的回复给服务器:
                                https协议在这一步,客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
                                如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。
                                （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
                                （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
                                （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
                                上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。
                            使用https协议时,还会返回服务器的最后回应给客户端:
                                服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。
                                （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
                                （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
                                至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。

                        2.传输数据;
                        3.断开链接,通过4次挥手:
                            客户端向服务器发数据传输完毕,断开链接的请求
                            服务端返回收到,准备断开给客户端
                            服务端返回已断开给客户端,要数据安全必需是服务端先断开链接
                            客户端返回已断开给服务器,但这条消息服务器收到没收到都无所谓
                        优点: 安全,准确度高, 例如:http和https协议,
                            像点外卖,要点菜下单建立连接,送餐,外卖员打电话让取餐,签收断开链接;
                        缺点: 传输效率低,耗资源,因为建立链接和断开链接要那么多步骤;
                    UDP无连接协议:
                        直接传,不建立链接,也不管对方是否收的到,没收到再传,过了传输时间对方还没收到就算了;
                        优点:及时性非常高,消耗资源少, 例如:视频聊天,直播等;
                            像去演唱会,台上的扔礼物给台下某个粉丝,只管扔,不管粉丝是否收到;
                        缺点: 不安全,数据准确度低,丢掉一两帧的数据很正常
                3.网络层   
                    IP协议,经过这里会拼上ip,自己的ip和将要发送到目的地的那台电脑的ip,通过电脑ip和端口号能知道消息是哪台电脑上的哪个应用发的数据,要发到哪里去;
                4.数据链路层  将上面的ip转二进制数据1和0,就是数字信号
                5.物理层   将二进制数据转换成光或电信号,通过网线或wifi等操作发送出去
            注意:
                接收数据的一方相反,通过物理层接收到数据,转成二进制数据,查看ip和端口号是否和接收的这台电脑对应,对上了就通过这台电脑上的这个端口号的应用解析数据,显示出来给用户;
                网络分层的概念是为了理解数据是怎么传输的,而人为区分的,实际传输中不存在,就像寄和收快递;


