前后端交互流程:
    1. 通过ajax下载数据;
    2.分析下载到的数据,转成对应数据结构;
    3.处理转换后的数据;
    
ajax 是异步的 javaScript 和 数据传输(xml);
    它将前台的数据传输到后台,将后台的数据返回到前台,数据传输可以同时进行,互不影响;
    就像人搬东西,左手拿前台数据,右手拿后台数据,互不影响, 而不是一次只拿前台数据,搬完下一趟再去搬后台数据;

    任何一个程序都是由很多段代码组成的,这很多段代码就是很多个小程序;
        同步: 就是阻塞,得前一个小程序先运行完,后一个才能运行; (open方法里默认是false,同步)
        异步: 就是可以同时运行,互不影响,各执行各的; open方法里写true是异步

数据传输:
    数据传输就像买的整套家具,运输时需要拆分装车,运回家又需要组装起来,家具不是随便拆的,需要按结构组成去拆,数据也是,json像随家具附送的家具组装说明书;
    数据在前端和后端都是通过数据结构(数组/对象)存储,传输时需要拆分,转成2进制传输,二进制传输最有效的方式是字符串,所以数据传输都是通过字符串传输,2种字符串传输格式,xml和json:
        xml(像html的写法):
            通过用户自定义的标签,把数据放在标签的内容里,来传输数据;
            优点:
                1.数据种类丰富,都是用户自定义的,标签名可以写任何单词,数据可以写任何内容;
                2.传输数据量非常大,标签可以重复出现,无限写下去;
            缺点:
                1.解析麻烦,
                2.不太适合轻量级数据;

        json(字符串类型,像数组和对象的写法,不是普通字符串,是json格式的字符串),95%的移动端应用都是json格式:
            优点:
                1.轻量级数据
                2.解析比较轻松
            缺点:
                1.数据种类较少, 比如: 美团,数据种类大都是 图片/名称/价格/销量/评论 这几种;
                2.传输量较小;

            json对象转换方法:
                数据结构转字符串:
                    前端: JSON.stringify(数组/字符串);
                    后端: json_encode();
                字符串转数据结构:
                    前端: JSON.parse(json格式的字符串);
                    后端: json_decode()

实现ajax请求,:

    1.创建ajax对象:
        var 变量 = new XMLHttpRequest();            相当于打开浏览器页面
        IE8以下兼容的写法,2种:
            第一种:
                var xml = null;
                if(window.XMLHttpRequest) {
                    xml = new window.XMLHttpRequest();
                } else{
                    xml = new ActiveXObject('Microsoft.XMLHTTP');
                }
            第二种:
                try{
                    var xml = new XMLHttpRequest();
                }catch(error){
                    var xml = new ActiveXObject('Microsoft.XMLHTTP');
                }

    2.调用open()方法传输数据:
        变量.open("请求方式","url",true);            相当于在浏览器的地址栏输入url
            参数1:请求方式;
            参数2:文件路径;
            参数3: true异步,false同步(默认值);  
    3.调用send()发送请求:                            相当于按enter键
        变量.send();
    4.使用onreadystatechange事件类型,等待数据响应:    相当于按完enter键后加载网页时转圈
        readyState属性,是请求状态,在状态发生变化的时候调用,有4个值:
            0   (初始化)调用open方法之前输出会返回0;
            1   (载入)调用send方法之后,发送请求;
            2   (载入完成)send方法完成,已经接受到所有的响应内容;
            3   (解析)正在解析下载到的数据
            4   (解析完成)可以在客户端调用了, 所以都要判断一下,在值==4的时候输出下载到的数据;
        status属性,(服务器的状态),是请求下载的这个资源的状态码, ==200的时候是下载成功,都要在readyState==4的时候才能接收到这个响应;  
            服务器的状态: 类似你客户端来拿我服务器的东西,我理不理你,让不让你拿,拒绝或者同意都要给你个态度回应你;
        responseText属性,是响应文本,存的是下载成功要输出给用户看的数据,以文本的形式返回给用户;
        responseXML属性,以XML的形式返回给用户;

        

用try..catch 或 try..throw..catch 进行判断比if..else执行效率高, 让代码更强壮,在新增代码时将新增的代码放到try里面执行,可以迅速捕获异常,常用来代码调试和后期维护:
    try{
        尝试执行的代码,如果执行正常,catch中的代码就不执行了;
    }catch(error){
        error 是错误对象,这里输出的是try中的代码执行报错的信息;
        补救代码,try报错时执行这里的代码;
    }

    try{
        尝试执行的代码,如果执行正常,catch中的代码就不执行了;
        throw new Error('错误提示信息');  
        这个throw是手动抛出异常,是程序员故意设置的错误信息,try执行到这行代码,就会停止执行throw下面的,直接去执行catch里的代码, new Error是创建错误对象;
    }catch(error){
        error 错误对象,这里输出的是try中的代码执行报错的信息;
        补救代码,try报错时执行这里的代码;
    }


get请求提交数据:
    数据通过查询字符串用键值对和&拼接,
    通过?将查询字符串拼接在url里,作为参数提交到后台,传给php里的全局get或post变量,数据以数组格式存储,
    再把php里调用数据的键对应的值提取出来,将要输出的内容返回到html页面,
    优点:
        传输数据简单
    缺点:
        不安全,数据都是暴露在url里可见的,
        url不能写太长,所以数据最大只能传输2kb,就无法实现图片/文件/视频等数据的上传了;

ajax实现get请求:
    将要传的参数写在open方法的第二个参数,url后面,用?拼接查询字符串;


post请求提交数据:
    通过浏览器内部进行提交,
    数据不会暴露在url里,安全,传输量大,

ajax实现post请求:
    在send方法之前设置请求头,也就是请求方式
        setRequestHeader('content-type', 'application/x-www-form-urlencoded');
    在send方法里传入参数,是不带?的查询字符串;

查询字符串,2种:
    ?键=值&键=值   这种叫search, ajax的get请求时用;
    键=值&键=值    这种叫querystring, ajax的post请求时用;

form表单提交数据的enctype属性,3种值:
    application/x-www-form-urlencoded:
        这是表单提交的默认格式，不支持文件类型.它的请求格式是键值对.

    multipart/form-data:
        既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来说明文件类型；content-disposition，用来说明字段的一些信息；
        提交文件必须要用这种格式，它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。所以可以上传多个文件。注意不能设置'Content-Type'='multipart/form-data'. 因为你手动设置了它,那么后面这个boundary=浏览器默认boundary就没了。这个是分界线，服务端是以这个分界线去key值.如果没有分界线服务端就不知道从从哪个位置开始取key`

    text/plain:
        是以纯文本格式（就是一段字符串）发送的. 如果你发送一个对象例如{ name:"leiwuyi", age:12 }一定要对它做JSON.stringfiy()处理，否则将传送[object Object]

提交数据:
    from表单的submit提交时,发送请求,会进行页面跳转,如果提交后需要跳转到其它页面用这种;
    ajax提交数据时,发送请求,会继续停留在当前页面,如果提交数据后要继续在当前页面,用这种;

前后端交互时,往数据库插入数据,不管成功或失败,都要有一个返回,所以反馈格式最好规定好格式,模拟浏览器的反馈格式,一个状态码,一个反馈信息:
$responseData = array("code" => 0, "message" => "");

同源和跨源:
    上网浏览的网页网站都是请求下载别人服务器上的数据,这都是跨源;
    同源策略:
        1.同协议     例如:http就不能直接下载https上的数据
        2.同域名/ip  例如:localhost
        3.同端口号   
    ajax下载数据只能下载同源(同服务器上)的数据,跨源(别人的服务器上)的数据是禁止下载的,控制台会报警告,已拦截跨源请求;
        标签的src属性没有跨源问题,可以无限制跨源,可以引入任何服务器下的任何后缀的文件;
        文件后缀的作用:
            1.对于计算机来说,文件后缀没有任何作用,里面的数据都会转成0和1,所以主要是数据是不是我们想要的,和后缀无关;
            2.后缀主要是给计算机上下载的软件用,让计算机能快速识别用哪个软件打开文件;
    跨源的方式,3种:
        1.修改ajax同源协议
            不建议,ajax禁止跨源,就是为了数据安全,否则你能随便访问别人的服务器,别人也能随便访问你的服务器;
        2.委托php文件进行跨源,因为php文件没有跨源的问题,可以让php文件去下载数据,ajax再访问自己服务器上的php文件,就像吃饭,不想自己去买,让外卖员送来,php文件相当于这个外卖员;
        3.JSONP跨源,必需是通过函数调用的形式下载数据:
            1.在当前要下载数据的页面专门用一个script标签,这个标签里只写这个函数声明和处理数据的代码,
                声明一个函数,函数设置一个形参,这个形参用来接收要下载的数据,在函数体里写处理数据的代码;
            2.在需要下载数据的时候,再写一个script标签(这个创建的标签插在哪里都能用),这个标签里面写动态创建script标签的代码,通过script的src属性,将需要下载的数据的url写上,并在url的查询字符串里拼接上面那个标签里 声明的函数的函数名(这里调用函数),访问的那个url上的数据将作为实参,传给我们声明的函数,这样数据就能在需要的时候下载,
                而不是直接将script标签写在head标签里,页面一加载就自动下载;
            3.当script标签插入到页面上的时候,就会通过src传的url,调用那个存数据的url里的函数,函数就会执行,进行传实参(实参是我们要下载的数据),给当前要下载数据的页面上声明的这个函数,这样就拿到我们需要下载的数据,就能成功下载数据了;
        
    
网络传输协议:
    数据在网络上传输的时候需要遵守的传输规则,就像开车要遵守的交通规则,是人为制定的;
    计算机网络:
        ISO组织规定:
            7层的网络分层
        程序员实际通用的:
            5层的网络分层:
                1.应用层  下载的各种app,例如QQ
                2.传输层   
                    TCP/UDP协议 端口号是在传输层的,经过这里会拼上一个端口号,告知数据哪个应用发的;
                    TCP面向连接协议:
                        1.建立连接,通过3次握手:
                            客户端向服务器发要下载某条数据的请求
                            服务端返回收到请求,准备好连接的回复
                            客户端返回我也准备好了,开始传输数据的回复给服务器;
                        2.传输数据
                        3.断开链接,通过4次挥手:
                            客户端向服务器发数据传输完毕,断开链接的请求
                            服务端返回收到,准备断开给客户端
                            服务端返回已断开给客户端,要数据安全必需是服务端先断开链接
                            客户端返回已断开给服务器,但这条消息服务器收到没收到都无所谓
                        优点: 安全,准确度高, 例如:http和https协议,
                            像点外卖,要点菜下单建立连接,送餐,外卖员打电话让取餐,签收断开链接;
                        缺点: 传输效率低,耗资源,因为建立链接和断开链接要那么多步骤;
                    UDP无连接协议:
                        直接传,不建立链接,也不管对方是否收的到,没收到再传,过了传输时间对方还没收到就算了;
                        优点:及时性非常高,消耗资源少, 例如:视频聊天,直播等;
                            像去演唱会,台上的扔礼物给台下某个粉丝,只管扔,不管粉丝是否收到;
                        缺点: 不安全,数据准确度低,丢掉一两帧的数据很正常
                3.网络层   
                    IP协议,经过这里会拼上ip,自己的ip和将要发送到目的地的那台电脑的ip,通过电脑ip和端口号能知道消息是哪台电脑上的哪个应用发的数据,要发到哪里去;
                4.数据链路层  将上面的ip转二进制数据1和0,就是数字信号
                5.物理层   将二进制数据转换成光或电信号,通过网线或wifi等操作发送出去
            注意:
                接收数据的一方相反,通过物理层接收到数据,转成二进制数据,查看ip和端口号是否和接收的这台电脑对应,对上了就通过这台电脑上的这个端口号的应用解析数据,显示出来给用户;
                网络分层的概念是为了理解数据是怎么传输的,而人为区分的,实际传输中不存在,就像寄和收快递;


