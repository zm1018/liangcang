模块化开发:
    模块是什么?
        程序员写的一个个js文件或一个个对象都是模块;
    模块化的特点:
        导出(对外暴露),和导入(引入别人写的文件,使用别人封装的属性或方法);
    这是ECMA6类之前的模块写法:
        1.采用闭包的写法,为了能后续拓展开发新的功能,在声明外层函数的地方写个形参,在调用函数的地方将拓展之前的函数作为参数传进去,就可以实现拓展了;
        2.但这样的拓展有顺序问题,后面开发的新功能必需要在之前的函数后面调用,否则报未定义错误,因为之前的函数还没声明,后面的函数就通过形参调用它,调用不到,
        3.解决顺序问题:在调用函数的地方加上 || {},这样即使后面的新功能先执行,形参也能拿到个空对象,就能顺利执行代码,不会报错,在向下执行时,就会将返回值作为实参传给之前的函数,之前的函数就有后面函数的新功能,实现拓展了,但返回值不能再是一个对象,必需是返回这个形参(形参接收的实参是调用函数那括号里传的函数),私有函数对外暴露要写成: 形参.属性名 = 私有函数;
        var 模块变量名 = (function(形参){
            var 私有变量 = 值;
            function 私有函数1(){
                代码..;
            }
            function 私有函数2(){
                代码..;
            }
            形参.对外暴露方法名1: 私有函数1;
            形参.对外暴露方法名2: 私有函数2;
            return 形参;     //这里是将别的函数作为实参返回
        })(拓展功能变量名 || {});  //这里解决调用时顺序原因报错的问题

        var 拓展功能变量名 = (function(形参){  //拓展功能的变量名必需和模块变量名相同
            function 私有函数3() {
                代码...;
            }
            形参.对外暴露名 = 私有函数3;
            return 形参;
        })(模块变量名 || {});


模块开发规范,3种:
    上面那种是我的写法,可能其他人有他们喜欢的写法,导致多种写法出现,如果我要用别人的模块还要学别人的调用语法,所以行业制定了模块开发的规范,让大家用统一格式去书写,统一格式去调用,
    就像电脑的usb接口,规范了接口的大小,厂家在生产U盘或鼠标等配件时都要遵守规范的尺寸,就能让我们买的任何牌子U盘或鼠标都能成功配上,插在上面用;

    1.CommonJS规范(后端,在服务器上执行的):
        这种是同步执行的,先将文件下载到本地,再执行引入下面的代码,如果引入时加载要10分钟,后面的代码就得10分钟后才能执行到;
        声明:
            module.exports = {
                对外暴露变量1: 私有方法1;
                对外暴露变量2: 私有方法2;
            }
        引入:
            var 变量 = require('./要变规范的js文件路径');
            var {变量1, 方法2} = require('./要变规范的js文件路径');
        调用:
            变量.对外暴露变量1();
            变量.对外暴露变量2();

    2.AMD规范(前端,客户端/浏览器上执行,已经快淘汰了)
        //全称Asynchronous Module Definition,异步模块定义的意思,这是异步执行的规范,依赖require.js文件,要使用必需先在script标签里引入require.js,否则无法使用;
        声明:
            define(function(){
                代码..;
                return { //返回的是一个对象
                    对外暴露变量名: 私有函数名,
                }
            })
        引入:
            所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
            第一个参数[module]，是一个数组，里面的成员就是要加载的模块；
            第二个参数callback，则是加载成功之后的回调函数。
            //回调函数的形参可以随便取名字,也可以直接用文件名字;
            require(['要变规范的js文件路径'],function(模块名){
                调用:     //这里是文件引入之后执行的:
                模块名.对外暴露变量名();
            })
            代码..;  //这里是异步执行,和引入文件一同执行,不管引入文件加载多长时间,都不影响;
        

    3.ECMA6模块化规范(通用的,前后端都支持,最好用)
    也是异步执行的,要去服务器环境里打开,否则报错浏览器http和https的跨域问题;
    基本导出的属性或方法在导入时要用{}解构导入,{}里也必需使用和导出时相同的名字,
    默认导出的属性或方法在导入时不要加{},不用和导出的名字相同,可以自己随便命名一个变量,它接收的就是default导出的所有东西;
    如果某个文件里没有对外导出任何东西,导入这个文件时,会默认接收到一个空对象,不会报错;
        导出方式有3种:
        1.直接声明时导出:
            export var a = 666;
            export后只能跟function、class、var、let、const、default、{}，export的作用就是给当前模块对象添加属性，方便后期导入到其他模块中;
        2.先声明再导出,export后面跟{},对象里面都是要导出的属性或方法:
            var a = 666;
            export { a }
        3.默认导出,写default关键字,一个js文件里只能有一个default:
            var a = 666;
            function b() {};
            export default { 
                a,
                b
            }

        导入的方式有5种, 前面必需要加./代表当前目录下的文件:
            只导入文件,这样会执行导入的这个文件里的代码,但它对外暴露的所有东西都不能使用:
                import "./js文件名"
            导入(声明时写default的默认导出):
                import 随便取的模块名 from './要变规范的js文件路径'
            导入(没写default的基本导出):
                import {属性1,方法1} from './js文件路径'  //导入某个属性或方法
                import {属性1 as 随便取的别名} from './js文件路径' //给导入的某个属性取别名
            导入所有的:
                import * as 随便取的别名 from './js文件路径' //导入全部对外暴露的属性和方法
            同时导入基本导出和默认导出:
                import 随便写个变量接收默认导出的,{属性1,方法1} from './js文件路径' 
        注意:
            1.基本导出的在导入时不含默认导出的那些属性和方法,默认导出的在导入时也不含基本导出的那些,如果要两种都包含,只能在导入时用*全部导入;
            2.一个文件里基本导出和基本导入可以使用多次;
        调用:
            模块名.对外暴露变量名;  //使用default导出的属性
            对外暴露的方法名();    //使用基本导出的方法
            别名.default.对外暴露变量名;  //使用*导入所有的里面default导出的那些属性或方法 
            别名.对外暴露变量名;  //使用*导入所有的里面基本导出的那些属性或方法 
        
        在html里使用模块,要把script标签的type属性值设置成module:
            这表示script标签引入的文件是模块化的,它里面定义的变量方法等都是局部作用域,只在那个文件里有效,即使这个html里定义了和引入文件里重名的变量,也不会有命名冲突互相影响;
            <script type="module"></script>


实现AMD规范的库require.js文件:
    开发中一个html页面需要依次加载多个js文件。这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。

    require.js的诞生，就是为了解决这两个问题：
        1）实现js文件的异步加载，避免网页失去响应；
        2）管理模块之间的依赖性，便于代码的编写和维护。

    使用:
        1.去官网下载require.js,保存到要加载的js文件夹里;
        2.引入require.js文件:
            <script src="js/require.js" defer async="true" ></script>
                async属性表明这个文件需要异步加载，避免网页失去响应。
                IE不支持这个属性，只支持defer，所以把defer也写上.
    
    用规范库写AMD模块化的步骤:
        1.html文件里加载入口文件main.js(文件名是自定义的)，我把它称为"主模块"，意思是整个网页的入口,代码写法:
            <script src="js/require.js" defer async="true" data-main="js/main"></script>
                data-main属性的作用是，指定网页程序的主模块。
                这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。
                一个html文件只能有一个script标签,只能引入一个入口文件,这入口文件不能再被其它html文件引入,而且入口文件不能重名;
                它有点像C语言的main()函数，所有代码都从这儿开始运行;
        
        2.每个模块js文件里声明函数:
            define(function(){
                var 变量=值;  //私有变量
                function 函数名(){  //私有方法
                    代码..;
                }
                return {  //返回一个对象,将私有方法对外暴露
                    对外暴露变量名:函数名,
                }
            })

            如果某一个模块js文件还要使用另一个模块js文件里的方法,需要在define前面传一个数组参数,里面写要引入的模块js文件,如果配置了路径,直接写名字,如果没配置路径,要写全路径;
            define(["moduleA"],function(moduleA){
                function 私有函数名() {
                引入模块调用方法的代码..;
                代码..;
                }
                return {
                    对外暴露变量名:私有函数名
                }
            })

        3.main.js文件用来管理当前html文件使用的所有js文件的,这里引入模块js文件,写法:
            require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){
        　　　　调用加载的这些模块里面的方法的代码..;
        　　});
                require()函数接受两个参数。
                第一个参数是一个数组，元素是所依赖的模块，上例就是['moduleA', 'moduleB', 'moduleC']，即主模块依赖这三个模块,这三个模块是与mian.js在同一目录下才行,否则要写全路径,或用下面的require.config()先配置好路径；
                第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。
                require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。

            用require.config()配置main.js里使用的模块的引入路径:
                require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。
                不和main.js在同一目录下引入模块,有两种写法。一种是逐一指定路径:
                　　require.config({
                　　　　paths: {
                　　　　　　"moduleA": "子文件夹名/moduleA",
                　　　　　　"moduleB": "子文件夹名/moduleB",
                　　　　　　"moduleC": "子文件夹名/moduleC"
                　　　　}
                　　});

                第二种则是直接改变基目录（baseUrl属性）:
                　　require.config({
                　　　　baseUrl: "js/子文件夹名",
                　　　　paths: {
                　　　　　　"moduleA": "moduleA",
                　　　　　　"moduleB": "moduleB",
                　　　　　　"moduleC": "moduleC"
                　　　　}
                　　});

                如果某个模块在另一台主机上，也可以直接指定它的网址，比如：
                　　require.config({
                　　　　paths: {
                　　　　　　"jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"
                　　　　}
                　　});

                shim属性，专门用来配置不兼容的模块(指的是不是通过define()声明的函数),也就是不是按照AMD规范编写的js文件,让这种文件也能正常通过require.js运行,写法:
                    require.config({
                        pahts:{
                            "变量1":"模块文件路径",
                            "变量2":"模块文件路径",
                            "变量3":"模块文件路径",
                        }
                        shim:{
                            //变量2文件必需要在变量1文件引入后执行,否则报错,可以这样设置引入执行顺序,也就是依赖关系,这样写变量2文件依赖变量1文件,就会先执行引入变量1文件
                            "变量2": ["变量1"], 
                            //声明不是用AMD规范写法写的模块,也就是不兼容的模块,可以不用遵从AMD规范,这里变量3是不兼容的模块
                            "变量3":{
                                exports: "_"
                            }
                        }

                    })
                
        
如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。工具下载地址:https://requirejs.org/docs/optimization.html