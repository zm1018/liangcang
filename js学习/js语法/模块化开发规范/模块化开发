模块化开发:
    模块是什么?
        程序员写的一个个js文件或一个个对象都是模块;
    这是ECMA6类之前的模块写法:
        1.采用闭包的写法,为了能后续拓展开发新的功能,在声明外层函数的地方写个形参,在调用函数的地方将拓展之前的函数作为参数传进去,就可以实现拓展了;
        2.但这样的拓展有顺序问题,后面开发的新功能必需要在之前的函数后面调用,否则报未定义错误,因为之前的函数还没声明,后面的函数就通过形参调用它,调用不到,
        3.解决顺序问题:在调用函数的地方加上 || {},这样即使后面的新功能先执行,形参也能拿到个空对象,就能顺利执行代码,不会报错,在向下执行时,就会将返回值作为实参传给之前的函数,之前的函数就有后面函数的新功能,实现拓展了,但返回值不能再是一个对象,必需是返回这个形参(形参接收的实参是调用函数那括号里传的函数),私有函数对外暴露要写成: 形参.属性名 = 私有函数;
        var 模块变量名 = (function(形参){
            var 私有变量 = 值;
            function 私有函数1(){
                代码..;
            }
            function 私有函数2(){
                代码..;
            }
            形参.对外暴露方法名1: 私有函数1;
            形参.对外暴露方法名2: 私有函数2;
            return 形参;     //这里是将别的函数作为实参返回
        })(拓展功能变量名 || {});  //这里解决调用时顺序原因报错的问题

        var 拓展功能变量名 = (function(形参){  //拓展功能的变量名必需和模块变量名相同
            function 私有函数3() {
                代码...;
            }
            形参.对外暴露名 = 私有函数3;
            return 形参;
        })(模块变量名 || {});


模块开发规范,3种:
    上面那种是我的写法,可能其他人有他们喜欢的写法,导致多种写法出现,如果我要用别人的模块还要学别人的调用语法,所以行业制定了模块开发的规范,让大家用统一格式去书写,统一格式去调用,
    就像电脑的usb接口,规范了接口的大小,厂家在生产U盘或鼠标等配件时都要遵守规范的尺寸,就能让我们买的任何牌子U盘或鼠标都能成功配上,插在上面用;
    1.CommonJS规范(在服务器上执行的):
        这种是同步执行的,先将文件下载到本地,再执行引入下面的代码,如果引入时加载要10分钟,后面的代码就得10分钟后才能执行到;
        声明:
            module.exports = {
                对外暴露变量1: 私有方法1;
                对外暴露变量2: 私有方法2;
            }
        引入:
            var 变量 = require('要变规范的js文件路径');
        调用:
            变量.对外暴露变量1();
            变量.对外暴露变量2();

    2.AMD规范(客户端/浏览器上执行)
        //全称Asynchronous Module Definition,异步模块定义的意思,这是异步执行的规范;
        声明:
            define(function(){
                代码..;
                return {
                    对外暴露变量名: 私有函数名,
                }
            })
        引入:
            所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
            第一个参数[module]，是一个数组，里面的成员就是要加载的模块；
            第二个参数callback，则是加载成功之后的回调函数。

            require(['要变规范的js文件路径'],function(模块名){
                调用:     //这里是文件引入之后执行的:
                模块名.对外暴露变量名();
            })
            代码..;  //这里是异步执行,和引入文件一同执行,不管引入文件加载多长时间,都不影响;
        

    3.ECMA6模块化规范
        //也是异步执行的;
        声明:
            export = {
                对外暴露变量名: 私有方法
            }
        引入:
            import 模块名 from '要变规范的js文件路径'
        调用:
            模块名.对外暴露变量名;


实现AMD规范的库require.js文件:
    开发中一个html页面需要依次加载多个js文件。这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。

    require.js的诞生，就是为了解决这两个问题：
        1）实现js文件的异步加载，避免网页失去响应；
        2）管理模块之间的依赖性，便于代码的编写和维护。
    使用:
        1.去官网下载require.js,保存到要加载的js文件夹里;
        2.引入require.js文件:
            <script src="js/require.js" defer async="true" ></script>
                async属性表明这个文件需要异步加载，避免网页失去响应。
                IE不支持这个属性，只支持defer，所以把defer也写上.
    
    用规范库写AMD模块化的步骤:
        1.html文件里加载入口文件main.js(文件名是自定义的)，我把它称为"主模块"，意思是整个网页的入口代码,写法:
            <script src="js/require.js" defer async="true" data-main="js/main"></script>
                data-main属性的作用是，指定网页程序的主模块。
                这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。
                一个html文件只能有一个script标签,只能引入一个入口文件,这入口文件不能再被其它html文件引入,而且入口文件不能重名;
                它有点像C语言的main()函数，所有代码都从这儿开始运行;
        
        2.每个模块js文件里声明函数:
            define(function(){
                var 变量=值;  //私有变量
                function 函数名(){  //私有方法
                    代码..;
                }
                return {  //返回一个对象,将私有方法对外暴露
                    对外暴露变量名:函数名,
                }
            })

            如果某一个模块js文件还要使用另一个模块js文件里的方法,需要在define前面传一个数组参数,里面写要引入的模块js文件,如果配置了路径,直接写名字,如果没配置路径,要写全路径;
            define(["moduleA"],function(moduleA){
                function 私有函数名() {
                引入模块调用方法的代码..;
                代码..;
                }
                return {
                    对外暴露变量名:私有函数名
                }
            })

        3.main.js文件用来管理当前html文件使用的所有js文件的,这里引入模块js文件,写法:
            require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){
        　　　　调用加载的这些模块里面的方法的代码..;
        　　});
                require()函数接受两个参数。
                第一个参数是一个数组，元素是所依赖的模块，上例就是['moduleA', 'moduleB', 'moduleC']，即主模块依赖这三个模块,这三个模块是与mian.js在同一目录下才行,否则要写全路径,或用下面的require.config()先配置好路径；
                第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。
                require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。

            用require.config()配置main.js里使用的模块的引入路径:
                require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。
                不和main.js在同一目录下引入模块,有两种写法。一种是逐一指定路径:
                　　require.config({
                　　　　paths: {
                　　　　　　"moduleA": "子文件夹名/moduleA",
                　　　　　　"moduleB": "子文件夹名/moduleB",
                　　　　　　"moduleC": "子文件夹名/moduleC"
                　　　　}
                　　});

                第二种则是直接改变基目录（baseUrl属性）:
                　　require.config({
                　　　　baseUrl: "js/子文件夹名",
                　　　　paths: {
                　　　　　　"moduleA": "moduleA",
                　　　　　　"moduleB": "moduleB",
                　　　　　　"moduleC": "moduleC"
                　　　　}
                　　});

                如果某个模块在另一台主机上，也可以直接指定它的网址，比如：
                　　require.config({
                　　　　paths: {
                　　　　　　"jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"
                　　　　}
                　　});

                shim属性，专门用来配置不兼容的模块(指的是不是通过define()声明的函数),也就是不是按照AMD规范编写的js文件,让这种文件也能正常通过require.js运行,写法:
                    require.config({
                        pahts:{
                            "变量1":"模块文件路径",
                            "变量2":"模块文件路径",
                            "变量3":"模块文件路径",
                        }
                        shim:{
                            //变量2文件必需要在变量1文件引入后执行,否则报错,可以这样设置引入执行顺序,也就是依赖关系,这样写变量2文件依赖变量1文件,就会先执行引入变量1文件
                            "变量2": ["变量1"], 
                            //声明不是用AMD规范写法写的模块,也就是不兼容的模块,可以不用遵从AMD规范,这里变量3是不兼容的模块
                            "变量3":{
                                exports: "_"
                            }
                        }

                    })
                
        
