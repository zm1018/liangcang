面向对象编程：
    面向对象是一个编程思想,支撑面向对象编程思想的语法是类(ECMA6新增)和对象,ECMA6之前,构造函数充当类的角色;
    面向对象是封装、继承、多态。
        继承：从父级构造函数继承到的属性和方法；例如：继承父母的长相；
        多态：子构造函数自己重写或新增的属性和方法； 
            例如：除了继承的部分外，自己和父母不一样的地方;
            多态,在原型上的自有属性和方法一定要写在原型继承代码的后面,不然会覆盖写在原型上的自有属性和方法;


类：
    可以看作是构造函数的另一种写法,数据类型就是个函数;
    在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称"实例"）共有的属性和方法。
    用class关键字定义一个类，是ECMA6新增概念;

    声明类:

        声明只有new类创建实例对象才能调用, 相当于在类的prototype属性上上边定义方法,语法：

            class 类名 {
                constructor(形参1,形参2..) {
                    this.属性1 = 值(指的是形参1);
                    this.属性2 = 值(形参2);
                }

                方法名() {
                    代码体..;
                }
                [方法名还可以传变量或表达式]() {
                    代码体..;
                }
            }
            调用,3种方式:
               1. var obj = new 类名(实参1,实参2..);  
                    obj.方法名(); 
               2. 类名.prototype.方法名();   这是通过类的prototype调用;
               3. 子类名.__proto__.prototype.方法名();  这是子类继承父类方法时调用;

        实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层:
            class 类名 {
                属性名 = 值;
                方法名() {
                    代码体;
                }
            }


        命名表达式声明类:
            变量名才是类的名字,class后面的类名只能在类的内部访问的到,外面调用会报未定义错误,语法:
                var 变量名 = class 类名 {
                    constructor(参数) {
                        this.属性名 = 参数;               
                    }
                    方法名() {}
                }

        声明匿名类:
            如果命名表达式class后面的类名内部不需要使用,就可以声明成匿名的, 和匿名函数类似,语法:
            var 变量名 = class {
                constructor(参数) {
                    this.属性名 = 参数;               
                }
                方法名() {}
            }


        快速给类添加多个方法:
            Object.assign方法的作用,是将除了参数1对象之外的所有参数对象合并到参数1里,可以通过这个合并对象的方法很方便地一次给类添加多个方法,写法:
                Object.assign(类名.prototype, {
                方法名1(){},
                方法名2(){},
                方法名3(){}
                });

        在方法名称前附加一个星号 * 可以将任何方法变为一个生成器:
            *方法名() {
                yield 值;
                return 值;
            }

        声明仅供当前类或当前类的子类使用的静态方法或静态属性,语法:
            class 类名 {              
                strict 属性名 = 值;
                strict 方法名() {};
            }
            类名.属性名 = 值;   //最好用这种写法写静态属性,写在类外面,用类名添加的;

            调用,3种方式:
                1.类名.方法名();    类直接调用;
                2.子类名.方法名();  子类继承父类的静态方法后,子类调用;
                3.class Son extends Foo {
                    return super.方法名();  子类继承父类的静态方法后,用super对象调用;
                }

        注意:
            ES6 明确规定，Class 内部只有静态方法，没有静态属性。
            现在有一个提案提供了类的静态属性，写法是在实例属性法的前面，加上static关键字。
            父类的静态方法可以被子类继承。
            如果静态方法包含this关键字，这个this指的是类，而不是实例。

        私有属性的提案:
            目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示, #属性名是私有属性,#方法名是私有方法,只在类的内部使用有效。 
            私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性。

    注意:
        1.类名后面的代码用{}括起来;
        2.constructor是一个构造函数，用于初始化class并创建一个对象,实例属性必需写在constructor(构造器的意思)里面,属性的形参写在构造器的()里面;
        3.方法直接写方法名,不要写function关键字;
        4.方法之间不需要逗号分隔，加了会报错。

    关于严格模式:
        由于js存在严格模式，类默认在严格模式下执行，如果该对象没有this的值，将不会返回其本身。
        传统的函数使用prototype就能返回其本身，因为传统的不在严格模式下执行。

    constructor()
        类的作用在于构建对象，而constructor构造方法就是用于构建对象实例。
        使用方法:
            在使用new关键字生成对象时，会自动调用执行constructor方法，最终return的结果就是生成的对象实例。
            当一个类没有constructor方法时会自动生成一个空的constructor方法，返回结果为空。
            用new关键字实例化对象时传入的参数会做为constructor构造函数的参数传入。
            该类的子类使用super关键字时会自动调用;

    总结:    
        1.constructor方法是类的默认方法，指向类本身,通过new命令生成对象实例时，自动调用该方法,
            constructor方法默认返回实例对象（即this）,
            constructor里面可以写return表达式。
        2.类的所有方法都定义在类的prototype属性上面;
            方法里如果写了this，默认指向类的实例。
            但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，容易报错。
        3.类的内部所有定义的方法，都是不可枚举的;
        4.类的内部，默认就是严格模式，所以不需要使用use strict指定运行模式,并且也无法退出严格模式。
        5.类没有变量提升,这种规定的原因与继承有关，必须保证子类在父类之后定义。
        6.在类的方法内部写相同的类名，会抛出错误。
        7.定义在this上的属性,用类创建实例对象后,是实例对象的属性,
            否则都是定义在原型上(即定义在class上),是类的属性,是实例对象继承的属性,
            可以用 实例对象.hasOwnProperty('属性名或方法名')检测是自己的还是继承的;


    调用类创建对象:
        var 对象名 = new 类名(实参1,实参2..);
        这里的实参传给类里的属性值;

    通过new创建的对象的__proto__属性为Class添加方法:
        对象名.__proto__.方法名 = function () { 代码体 };

        这里这个方法会改变创建对象的类,是直接添加到类上了,所有通过new创建出来的对象都能共用,
        如果类里面有相同名字的方法,它会覆盖那个类里名字相同的方法,导致其它new创建出来的对象,用类里的原来那个方法都变成了这个新增方法,所以要慎用;

        __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。


    extends
        用来继承类;
        语法:
            class 子类 extends 父类名 {
                constrcutor(父类参数们,子类自己的参数) {
                    super(父类参数们); //继承父类的所有属性;

                    this.子类属性名 = 属性值;  // 多态,自己独有的,父类和其它子类没有的属性;
                }
                方法名() {};  //多态,自己独有;
            }
        类的所有方法都定义在类的prototype属性上面，所有类中定义的方法都会被实例继承，
        如果在类方法前面加上static关键字就不会被实例继承了,但可以通过super继承调用 ，子类继承父类的static方法也只能通过  子类名.静态方法  调用。
        如果一个对象没有构造函数，将不能进行继承。
    
    super
        用来调用超类(也就是子类用super()调用父类);

    new.target属性:
        用来设置构造函数怎么调用;
        例如:必需通过new调用,或者必需通过子类调用...
        返回值:
            new命令作用于的那个构造函数。
            如果构造函数不是通过new命令或Reflect.construct()调用的，返回undefined，
            Class 内部调用new.target，返回当前 Class;
            子类继承父类时，new.target会返回子类。


构造函数:
    构造函数是指某一类事物，模仿类的作用，相当于数学中的公式，是抽象的；
    是把对象的一些相同的属性或方法抽象出来封装到函数里，这个函数就称为构造函数，
    这个函数里封装的不是普通代码，是对象；  
    例如：
        苹果、明星都是构造函数。
        这个苹果，明星王一博等都是对象；
    作用:
        通过构造函数我们就不用反复去重新定义对象们相同的属性和方法,传不同的参数就能生成不同对象的属性值，解决有相同属性和方法的对象,里面的代码的重复问题;

    封装构造函数语法,2种：
        1.这种直接写在构造函数里面的方法不是共享的,每个用此构造函数创建出来的对象,它们拥有相同的名字和功能的方法,但方法的内存地址不同,所以不是同一个东西:

            function 构造函数名(形参1,形参2....) {
                this.属性名1 = 值1（这里的值指的是构造函数的形参）;
                this.属性名2 = 形参2;
                this.方法名 = function(形参...) {
                    匿名函数的函数体代码...;
                };
            }

        2.自定义类型，也叫引用类型:
            使用构造函数和原型组合起来创建对象;
            这是常用的自定义类型的创建方式，构造函数用来定义实例属性，而原型用于定义共享方法和共享属性。
            每个函数上都有一个prototype原型属性,这个属性是个对象类型,这个原型对象在普通函数上没什么用,只有在构造函数上有较大的作用,将构造函数的方法添加在prototype原型对象上,让构造函数创建出来的对象都能共享原型上的所有方法;

            function 构造函数名(形参1...) {
                this.属性名1 = 值1;
            }
            构造函数名.prototype = {
                方法名1: function(形参1...) {
                    函数代码体...;
                },
                方法名2: function(形参1...) {
                    函数代码体...;
                }
                方法3...可以添加多个共用的方法
            }

        注意：
            1.构造函数名的首字母一定要大写；
            2.构造函数不需要写return就可以返回结果；
            3.调用构造函数必需使用new操作符调用；
            4.构造函数内部的属性和方法前面必需加this.开头，以;结尾。

    构造函数创建对象，语法：
        var 对象名 = new 构造函数名(实参1,实参2....);

    构造函数继承,5种方式:
        一个构造函数想将另一个构造函数中所有的属性和方法拿过来用，这就是继承。
        那么我作为一个继承的引用类型我能获得谁的属性和方法，在这个问题上就会有原型链的概念。
        构造函数来创建对象的时候,对象实例内部会自动保存一个指向构造函数的 prototype 对象的一个属性__proto__，所以在每一个对象实例中就可以访问构造函数的 prototype 所有拥有的全部属性和方法;

        这2种方式,属性和方法都是写在this上的:
            第一种,在子构造函数里用call或apply强制改变父构造函数的this指向:
                var 父构造函数.apply(this, arguments);

            第二种，将构造函数的实例赋值给子构造函数的prototype属性,:
                子构造函数.prototype = new 父构造函数;  
                子构造函数.prototype.constructor = 子构造函数;
                    第一句代码:
                        将子的prototype对象指向一个父的实例,相当于完全删除了prototype 对象原先的值，然后赋予一个新值,强制改变了 子prototype的constructor指向父,实现继承。
                    第二句代码:
                        因为每一个实例也有一个constructor属性，默认调用它的构造函数prototype对象的constructor属性,第一行代码改成 new 父 后,实例对象的constructor也会指向它的构造函数的父构造函数,会导致继承链的紊乱；
                        所以要再将 子.prototype.constructor是指向 子, 让实例对象重新正确的指向创建它的构造函数; (相当于孩子本来是爸爸生的,但第一句代码导致爸爸生的孩子变成了爷爷生的,第二句代码必需重新将孩子改成爸爸生的,不然乱套了);
                        这样子创建的实例对象才能既拥有子的所有属性和方法又拥有父的所有属性和方法;

        这3种方式,属性和方法都是写在prototype上的:
            第三种,直接赋值继承写在prototype上的共有属性和方法,这种是非常错误的写法,会改变父的原型,不建议用:
                子.prototype = 父.prototype;
　　            子.prototype.constructor = 子;
                    第一句代码:
                        比第二种方式省内存。缺点是 子.prototype和 父.prototype现在指向了同一个对象，那么任何对子.prototype的修改，都会反映到父.prototype。
                    第二句代码:
                        这一句实际上把 父.prototype对象的constructor属性也改掉了,也指向了 子,也导致继承链的紊乱；(本来儿子是父亲生的,现在变成了父亲是儿子生的);


            第四种，利用一个空函数作为中介:
                子.prototype = Object.create(父.prototype);  
                子.prototype.constructor = 子;
                    第一句代码:
                        Object.create()创建一个和父原型一样的新对象,赋值给子构造函数原型,任何对子.prototype的修改，不会影响父原型;

                或者封装一个空对象作为中介的函数:
                    function extend(Child, Parent) {
                　　　　var F = function(){};
                　　　　F.prototype = Parent.prototype;
                　　　　Child.prototype = new F();
                　　　　Child.prototype.constructor = Child;
                　　　　Child.uber = Parent.prototype;   
                        //最后这一句代码: 意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是"向上"、"上一层"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。
                　　}
                    创建实例对象:
                        extend(子构造函数, 父构造函数);
                        var 实例对象 = new 子构造函数();

            第五种,把父对象的所有属性和方法，拷贝进子对象:
                function extend(Child, Parent) {
            　　　　var p = Parent.prototype;
            　　　　var c = Child.prototype;
            　　　　for (var i in p) {
            　　　　　　c[i] = p[i];
            　　　　　　}
            　　　　c.uber = p;
            　　}
                这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。
            或者直接在子构造函数下面写循环:
                for(var i in 父构造函数.prototype) {
                    子构造函数.prototype[i] = 父构造函数.prototype[i];
                }
                

                创建实例对象:
                    extend(子构造函数, 父构造函数);
                    var 实例对象 = new 子构造函数();

               

自定义类的极简写法:
    用一个对象模拟"类"。在这个类里面，定义一个构造函数createNew()，用来生成实例。
    例如:
        var Cat = {    //创建一个对象Cat;
    　　　　createNew: function(){  //创建一个构造函数createNew(),用来生成实例对象;
    　　　　　　var cat = {};       // 定义一个空对象cat;
    　　　　　　cat.name = "大毛";  // 给空对象cat添加属性;
    　　　　　　cat.makeSound = function(){  // 给对象cat添加方法;
                    alert("喵喵喵"); 
                };
    　　　　　　return cat;    //返回cat对象;
    　　　　}
    　　};
    调用对象Cat的createNew()方法，创建实例对象:
　　    var cat1 = Cat.createNew();
    使用类里的方法:
　　    cat1.makeSound(); // 喵喵喵;

    继承:
        让子类继承父类，只要在子类的createNew()方法中，调用父类的createNew()方法即可。
        var cat = 父类名.createNew();

    私有属性和私有方法:
        在createNew()方法中，只要不是定义在cat对象上的方法和属性，都是私有的。
        var sound = "喵喵喵";  //这种,不是通过cat.添加的属性或方法,是私有的,外面创建的实例对象无法访问;
    
    数据共享:
        让所有实例对象，能够使用同一个属性或方法,只要把这个内部数据，封装在类对象的里面、createNew()方法的外面即可。
        例如:
            var Cat = {   
        　　　　sound : "喵喵喵",        // 属性定义在这里作为共享属性,通过类名Cat调用;
        　　　　createNew: function(){  
        　　　　　　var cat = {};
        　　　　　　cat.makeSound = function(){
                        alert(Cat.sound); 
                    };
        　　　　　　cat.changeSound = function(x){  // 用户输入参数可以更改共享属性sound的值;
                        Cat.sound = x;   // 将用户传入的参数作为共享属性的新属性值;
                    };
        　　　　　　return cat;
        　　　　}
        　　};


普通对象的继承,一个普通对象继承另一个普通对象的属性和方法:
    浅拷贝:
        除了使用"prototype链"以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。

        下面这个函数，就是在做拷贝：

        　　function extendCopy(p) {
        　　　　var c = {};
        　　　　for (var i in p) {
        　　　　　　c[i] = p[i];
        　　　　}
        　　　　c.uber = p;
        　　　　return c;
        　　}

        使用的时候，这样写：
    　　    var Doctor = extendCopy(Chinese);

        但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。
        所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做"浅拷贝"。

    深拷贝:
        怎么才能深拷贝,就是拷贝复杂数据类型的内容,不是拷贝地址,不管其他对象改不改变数组的元素或对象,它都不会再受影响;
        所谓"深拷贝"，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用"浅拷贝"就行了。
        　　function deepCopy(p, c) {
        　　　　var c = c || {};
        　　　　for (var i in p) {
        　　　　　　if (typeof p[i] === 'object') {
        　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : {};
        　　　　　　　　deepCopy(p[i], c[i]);
        　　　　　　} else {
        　　　　　　　　　c[i] = p[i];
        　　　　　　}
        　　　　}
        　　　　return c;
        　　}

        使用的时候这样写：
　　        var Doctor = deepCopy(Chinese);



原型是相对于构造函数(类)的叫法(或者说概念):
    prototype原型:
        prototype属性是函数所独有的,每一个函数在创建的时候都会默认的分配一个prototype属性，构造函数的prototype原型对象是由Object()构造函数创建。
        它是一个指针，从构造函数指向一个实例对象, 实例通过指针能访问指针指向的内存空间,实例对象只是获取了一个指向原型的指针，他并没有改变原型的权利。
        作用:
            是包含所有实例共享的属性和方法，让该函数所实例对象们都可以找到公用的属性和方法。
            所以写在prototype上的属性或方法,在内存中只用生成一次，然后所有实例对象都通过指针指向的那个内存地址,访问地址里存的属性或方法,实现共享功能;
            
            
        构造函数的原型对象prototype就是构造函数自己,它创建的实例对象的原型链对象__proto__也是指该构造函数，prototype和__proto__这二指向同一个引用(构造函数);
        但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性;

        

    constructor属性:
        它存在于每一个function 的prototype 属性中,所有构造函数的终点是Function。
        创建实例对象时,每个实例对象都自动含有一个constructor属性，指向它们的构造函数。
        ES人为的将prototype对象的constructor属性指向构造函数,否则将无法判断一个对象实例具体由哪一个构造函数创建。
        作用:
            实例对象的 constructor 属性指向创建此实例的构造函数,也就是实例对象实例是由谁创建的就指向谁,每一个对象实例都可以通过 constrcutor 对象访问它的构造函数。

        构造函数的原型是function,所以构造函数也是一个对象实例，它自然也有constructor属性，不过此时constructor是构造函数的静态属性,构造函数上的constructor 不属于 prototype, 它是 Function 构造函数的引用,它和 prototype 上 constructor 不是同一个对象，他们是共存的。
            
       

原型链是相对于构造函数(类)的实例对象的叫法:
    __proto__属性:
        实例对象的__proto__属性,指向它的构造函数的原型对象prototype;
        作用:
            用来实现继承的;
        原型链:
            访问实例的某个属性时，对象自身没找到，会尝试从父原型对象中去找，父原型对象没有，在从父原型对象的原型(爷爷)去找，查找会沿着创建它的构造函数原型一级一级向上查找，直到找到这个属性或者到达原型链末端null(就是原型链的终点Object.prototype) 才会停下来，这种通过__proto__属性来连接对象直到null的一条链，这就是原型链。
            这是比较消耗内存的，所以我们不能将原型链定义得太长。

         __proto__(原型的意思)和constructor(构造器的意思)属性 是对象所独有的；
          __属性__这种双下划线的属性,叫 dunder; 是 Double UNDERscore（中文双下划线）的缩写，分别取Double的D 和 Underscore的Under组成。这样取名后方便发音。
 
 3者之间的关系:
        函数创建的对象.__proto__ === 该函数.prototype，
        该函数.prototype.constructor===该函数本身;
            

    instanceof关键字
        判断一个对象是否是由某个构造函数构造出来的;
        语法:
            对象 instanceof 构造函数;
        返回值:
            是返回true;否则返回false;

    isPrototypeOf()
        用来判断，某个proptotype对象和某个实例之间的关系。
        语法:
            构造函数.prototype.isPrototypeOf(实例对象));
        返回值:
            实例对象是构造函数原型创建出来的,返回true;否则返回false;

    hasOwnProperty('属性名')
        每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是自有属性，还是继承自prototype对象的属性。
        语法:
            实例对象.hasOwnProperty('属性名');
        返回值:
            自有属性返回true;
            继承父原型对象上的属性返回false;

    in运算符:
        可以用来判断，某个实例是否含有某个属性，不管是不是本地属性;
        还可以用for..in..来遍历实例对象的所有属性;
        语法:
            '属性名' in 实例对象;
        返回值:
            含有返回true;
            不含返回false;



new操作符在创建对象时会做5件事情：
    1.在内存中创建一个空的对象； 
    2.让新创建的空对象的prototype原型属性指向构造函数的原型,
        空对象.prototype = 构造函数.prototype;
    3.将构造函数的this绑定到新创建的空对象上,让this指向这个内存中新创建的对象
        (可以看成像平时调用函数的方法差不多,执行: 空对象.构造函数(), 这时this的主人就是空对象了,构造函数的属性就成了空对象的属性,创建空对象时传的参数,就是属性的值)
    4.执行构造函数里的代码，给这个新创建的对象添加构造函数里的属性和方法。
    5.返回构造函数的执行结果,返回值是个对象类型,
        也就是当构造函数上面的代码都执行完后，new干了return的返回工作,返回这个新创建的对象，所以构造函数里不需要写return。

this变量:   
    只要封装函数,任何一个函数系统都会内置一个叫this的变量;
    由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。


    this指向:永远指向当前函数的主人,谁调用function函数，this就指向谁。
        function 函数名() {}; 这种函数直接是function开始的,是在全局环境里执行的函数,所以this指向全局环境,也就是window,因为所有内容都归属window,所以它的主人是window;
        var 对象名 = {方法名:function(){} }; 对象内部的方法,是在这个对象里运行的,所以this的主人是这个对象;

    强制改变this指向,用this时就不用再费力去找它的主人了,3种方法:
        call()
            格式:函数名.call('this新主人名字',原函数的参数1,参数2..);
            参数2个:
                第一个:传入该函数this指向的对象(新函数的主人),传入什么this就强制指向什么;
                第二个:传入原函数的参数,有几个传几个;
        apply()
            格式:函数名.apply('this新主人名字',[原函数的参数1,参数2..]);
            参数2个:
                第一个:传入该函数this指向的对象(新函数的主人),传入什么this就强制指向什么;
                第二个:传入一个数组,数组的元素是原函数的参数;

        上面两种方法是调用立即执行改的,下面这种是预设,先改但不执行,调用它的返回值的时候才会执行;

        bind() 
            预设this的指向,先设置好this的新主人,这个新主人就是bind的参数,设置并不会执行函数体,在调用函数的时候才会执行函数体,这时this的指向已经被改变成bind的参数了;
            格式: 
                var res = 函数名.bind('this新主人名字');  这里只改变this指向;
                res(原函数的参数1,参数2..);               这里执行改变后的函数;
                    直接调用bind()的返回值是一个函数,有和调用方(函数名)一模一样的函数体和功能,
                    但this指向已经变成了bind的参数,这时函数不会执行;
                    再调用返回值,并传参,返回值就是那个改了this主人的函数;
            返回值:
                一个函数,是this的新主人;

            和上面两个方法一样立即执行改主人,可以简写成: 
                函数名.bind('this新主人名字')(原函数的参数1,参数2..);


   
 
JS中的构造函数的静态属性、静态方法、及实例属性、实例方法、和原型属性、原型方法:
    1.静态属性/静态方法:
        定义在构造函数上的属性和方法,
        写法:
            构造函数名.属性名 = 值;
            构造函数名.方法名 = function(){};
        谁调用:
            构造函数名.属性/方法;

            只能通过构造函数名来调用,属于内部属性和方法,
            用new创建出来的对象是不能调用的,会报未定义错误。

    2.实例属性,实例方法:
        定义在构造函数内部绑定到this上的属性和方法,或定义在由构造函数创建的对象上的属性和方法。
        在this上绑定的写法:
            this.属性名 = 值;
            this.方法名 = function() {};
        谁调用:
            new创建出来的对象.属性/方法;
            只能通过new创建出来的对象调用,构造函数自己不能调用;

        定义在由构造函数创建出来的对象上的写法:
            new创建出来的某个对象.属性名 = 值;
            new创建出来的某个对象.方法名 = function() {};
        谁调用:
            这种只有当前这个实例对象自己能用,其它用new创建出来的对象不能用,构造函数也不能用,有点像当前这个实例对象新增的自己的属性和方法;

    3.原型属性/原型方法:
        定义在构造函数原型对象prototype上的属性和方法,
        写法:
            构造函数名.prototype = {
                属性名: 属性值,
                方法名: function() {};
            }
        谁调用:
            new创建出来的对象.属性/方法；
            构造函数名.prototype.属性/方法;
            
            这些属性可以通过new创建出来的对象直接调用,也可以通过构造函数名直接调用。
    总结:
        实例属性和方法就是只有实例可以调用，
        静态属性和方法只有构造函数可以调用，
        原型属性和方法是实例和构造函数都可以调用，是共享的方法。


js中类的静态属性、静态方法、实例属性、实例方法：
    实例属性/方法:
        所有在类中定义的方法，都会被实例继承。
        谁调用:
            类创建的对象名.方法();
            只能通过类创建的对象调用;

    静态属性/方法:    
        如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
        父类的静态方法，可以被子类继承。
        静态方法也是可以通过super对象调用;
        如果静态方法包含this关键字，这个this指的是类，而不是实例对象。
        写法:
            strict 方法名() {};
        谁调用:
            类名.方法名();
            只能通过类调用;

