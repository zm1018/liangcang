面向对象编程：
    面向对象是一个编程思想,支撑面向对象编程思想的语法是类(ECMA6新增)和对象,ECMA6之前,构造函数充当类的角色;

类：
    可以看作是构造函数的另一种写法,数据类型就是个函数;
    在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称"实例"）共有的属性和方法。
    
    用class关键字定义一个类，是ECMA6新增概念;

        声明只有new类创建实例对象才能调用,语法：
            class 类名 {
                constructor(形参1,形参2..) {
                    this.属性1 = 值(指的是形参1);
                    this.属性2 = 值(形参2);
                }

                方法名() {
                    代码体..;
                }
                [方法名还可以传变量或表达式]() {
                    代码体..;
                }
            }

        实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层:
            class 类名 {
                属性名 = 值;
                方法名() {
                    代码体;
                }
            }

        声明匿名类:
            和匿名函数类似，类依旧可以进行匿名声明,语法:
            var 变量名 = class {
                constructor(参数) {
                    this.属性名 = 参数;               
                }
                方法名() {}
            }

        命名表达式声明类:
            class后面的类名只能在类的内部访问的到,外面调用会报未定义错误,语法:
                var 变量名 = class 类名 {
                    constructor(参数) {
                        this.属性名 = 参数;               
                    }
                    方法名() {}
                }

        快速给类添加多个方法:
            Object.assign方法的作用,是将除了参数1对象之外的所有参数对象合并到参数1里,可以通过这个合并对象的方法很方便地一次给类添加多个方法,写法:
                Object.assign(类名.prototype, {
                方法名1(){},
                方法名2(){},
                方法名3(){}
                });

        在方法名称前附加一个星号 * 可以将任何方法变为一个生成器:
            *方法名() {
                yield 值;
                return 值;
            }

        声明只有类能调用的静态属性和方法的写法:
            class 类名 {
                strict 属性名 = 值;
                strict 方法名() {};
            }
        注意:
            ES6 明确规定，Class 内部只有静态方法，没有静态属性。
            现在有一个提案提供了类的静态属性，写法是在实例属性法的前面，加上static关键字。

        私有属性的提案:
            目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示, #属性名是私有属性,#方法名是私有方法,只在类的内部使用有效。 看看m
            私有属性不限于从this引用，只要是在类的内部，实例也可以引用私有属性。

    注意:
        1.类名后面的代码用{}括起来;
        2.constructor是一个构造函数，用于初始化class并创建一个对象,实例属性必需写在constructor(构造器的意思)里面,属性的形参写在构造器的()里面;
        3.方法直接写方法名,不要写function关键字;
        4.方法之间不需要逗号分隔，加了会报错。

    关于严格模式:
        由于js存在严格模式，类默认在严格模式下执行，如果该对象没有this的值，将不会返回其本身。
        传统的函数使用prototype就能返回其本身，因为传统的不在严格模式下执行。

    总结:    
        constructor方法是类的默认方法，指向类本身,通过new命令生成对象实例时，自动调用该方法,constructor方法默认返回实例对象（即this）。
        类的所有方法都定义在类的prototype属性上面;
        类的内部所有定义的方法，都是不可枚举的;
        类的内部，默认就是严格模式，所以不需要使用use strict指定运行模式,并且也无法退出严格模式。
        类没有变量提升,这种规定的原因与继承有关，必须保证子类在父类之后定义。
        在类的方法内部写相同的类名，会抛出错误。
    


    调用类创建对象:
        var 对象名 = new 类名(实参1,实参2..);
        这里的实参传给类里的属性值;

    通过new创建的对象的__proto__属性为Class添加方法:
        对象名.__proto__.方法名 = function () { 代码体 };

        这里这个方法会改变创建对象的类,是直接添加到类上了,所有通过new创建出来的对象都能共用,
        如果类里面有相同名字的方法,它会覆盖那个类里名字相同的方法,导致其它new创建出来的对象,用类里的原来那个方法都变成了这个新增方法,所以要慎用;

        __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。


    extends
        用来继承类;
        类的所有方法都定义在类的prototype属性上面，所有类中定义的方法都会被实例继承，
        如果在类方法前面加上static关键字就不会被实例继承了,但可以通过super继承调用 ，子类继承父类的static方法也只能通过  子类名.静态方法  调用。
        如果一个对象没有构造函数，将不能进行继承。
    
    super
        用来调用超类(也就是子类用super()调用父类);

    new.target属性:
        用来设置构造函数怎么调用;
        例如:必需通过new调用,或者必需通过子类调用...
        返回值:
            new命令作用于的那个构造函数。
            如果构造函数不是通过new命令或Reflect.construct()调用的，返回undefined，
            Class 内部调用new.target，返回当前 Class;
            子类继承父类时，new.target会返回子类。



    
        




JS中的构造函数的静态属性、静态方法、及实例属性、实例方法、和原型属性、原型方法:
    1.静态属性/静态方法:
        定义在构造函数上的属性和方法,
        写法:
            构造函数名.属性名 = 值;
            构造函数名.方法名 = function(){};
        谁调用:
            构造函数名.属性/方法;

            只能通过构造函数名来调用,属于内部属性和方法,
            用new创建出来的对象是不能调用的,会报未定义错误。

    2.实例属性,实例方法:
        定义在构造函数内部绑定到this上的属性和方法,或定义在由构造函数创建的对象上的属性和方法。
        在this上绑定的写法:
            this.属性名 = 值;
            this.方法名 = function() {};
        谁调用:
            new创建出来的对象.属性/方法;
            只能通过new创建出来的对象调用,构造函数自己不能调用;

        定义在由构造函数创建出来的对象上的写法:
            new创建出来的某个对象.属性名 = 值;
            new创建出来的某个对象.方法名 = function() {};
        谁调用:
            这种只有当前这个实例对象自己能用,其它用new创建出来的对象不能用,构造函数也不能用,有点像当前这个实例对象新增的自己的属性和方法;
    3.原型属性/原型方法:
        定义在构造函数原型对象prototype上的属性和方法,
        写法:
            构造函数名.prototype = {
                属性名: 属性值,
                方法名: function() {};
            }
        谁调用:
            new创建出来的对象.属性/方法；
            构造函数名.prototype.属性/方法;
            
            这些属性可以通过new创建出来的对象直接调用,也可以通过构造函数名直接调用。
    总结:
        实例属性和方法就是只有实例可以调用，
        静态属性和方法只有构造函数可以调用，
        原型属性和方法是实例和构造函数都可以调用，是共享的方法。

js中类的静态属性、静态方法、实例属性、实例方法：
    实例属性/方法:
        所有在类中定义的方法，都会被实例继承。
        谁调用:
            类创建的对象名.方法();
            只能通过类创建的对象调用;

    静态属性/方法:    
        如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
        父类的静态方法，可以被子类继承。
        静态方法也是可以通过super对象调用;
        如果静态方法包含this关键字，这个this指的是类，而不是实例对象。
        写法:
            strict 方法名() {};
        谁调用:
            类名.方法名();
            只能通过类调用;

