<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // 内置Array对象的属性或方法演示：
        var arr = [1, 2];
        // length属性返回一个数字类型的数，这个数是数组的长度，也就是数组里元素的个数
        console.log(arr.length);

        // 在原数组前面添加数组元素，返回值是新数组的长度
        arr1 = arr.unshift('pink', 3);
        // 输出unshift()方法的返回值，得到4，是新数组的长度
        console.log(arr1);
        // 输出新数组，得到["pink", 3, 1, 2]
        console.log(arr);

        // 在原数组末尾添加数组元素，返回值是数组的长度
        arr2 = arr.push(5);
        // 输出push()方法的返回值，得到4，是新数组的长度
        console.log(arr2); 
        // 输出新数组， 得到["pink", 3, 1, 2, 5]
        console.log(arr);

        // 删除数组的第一个元素，一次只能删除一个元素
        arr3 = arr.shift();
        // 输出shift()方法的返回值
        console.log(arr3);
        // 输出删除第一个元素后的新数组
        console.log(arr);

        // 删除数组的最后一个元素，一次只能删除一个元素
        arr4 = arr.pop();
        // 输出pop()方法的返回值
        console.log(arr4);
        // 输出删除最后一个元素后的新数组
        console.log(arr);


        // 判断一个参数是不是数组类型，是返回true，不是返回false，两种方式：
        // 一、
        console.log(arr instanceof Array); // arr是数组类型，返回true
        console.log((12, 3) instanceof Array); // (12,3)不是数组类型，返回false
        // 二、
        console.log(Array.isArray(arr)); // arr是数组类型，返回true
        console.log(Array.isArray(3, 5, 7)); // 3，5，7不是数组类型，返回false

        // 筛选数组案例，把超过2000的元素删除，剩下的元素放在新数组里存储

        var arra = [1500, 1200, 2000, 2100, 1800],
            arra1 = [];
        for (var i = 0; i < arra.length; i++) {
            if (arra[i] < 2000) {
                // var arr = arra[i]; 这个索引为i的元素不是数组，所以报类型错误。
                // arra.shift(); 不需要写删除，直接把判断条件写成小于2000的添加到新数组就行了
                arra1.push(arra[i]); // 要用push()方法，从末尾添加数组元素，这样索引号才对。
            }
        }
        console.log(arra1);

        // reverse()翻转数组元素，返回值是翻转后的数组
        var aa = [3, 5, 7];
        console.log(aa.reverse()); // 得到[7, 5, 3]
        var bb = ['j', 'a', 'b']
        console.log(bb.reverse());

        // sort()将数组元素进行排序（冒泡排序）
        var cc = [3, 9, 7];
        console.log(cc.sort()); // 得到[3, 7, 9],不传参数，数字类型的元素默认从小到大排序
        cc = [3, 9, 7, 20];
        // 两位数的无法进行正确的排序，需要传参数写函数来解决
        console.log(cc.sort()); // 得到[20, 3, 7, 9]，它以两位数的第一位数和后面的数进行比较。
        cc = ['c', 'b', 'de', 'ja', 'a'];
        console.log(cc.sort());
        cc = ['pink', 'red', 'blue']
        console.log(cc.sort());

        // 两位数及以上的数字用sort()正确的排序,两种方法：
        cc = [33, 20, 58, 86, 77, 7, 15];
        console.log(cc.sort((a, b) => a - b)); // 从小到大排序
        console.log(cc.sort((a, b) => b - a)); // 从大到小排序
        // 从小到大排序 
        console.log(cc.sort(function(a, b) {
            return a - b;
        }));
        // 从大到小排序
        console.log(cc.sort(function(a, b) {
            return b - a;
        }));


        // 判断一个元素是否在一个数组里面，在返回该元素的索引号，不在返回-1
        // indxeOf()
        var d = ['pink', 1, 5, 8, 9];

        console.log(d.indexOf(2)); // 返回-1，表示元素2不在数组d里。
        console.log(d.indexOf('pink')); // 返回0，表示元素在数组d里索引为0的位置

        // 从索引为2的位置开始查找元素5是否在数组d里
        console.log(d.indexOf(5, 2)); // 返回2，表示元素在数组d里索引为2的位置

        // 从索引为3的位置开始查找元素5是否在数组d里
        console.log(d.indexOf(5, 3)); // 返回-1，表示数组d里索引从3的位置开始到结束没有元素5。

        // 从索引为-4的位置开始（也就是正着数索引为1的位置）查找到最后一个元素的索引-1位置结束，判断元素5是否在数组d里
        console.log(d.indexOf(5, -4)); // 返回2，表示元素5在数组d里索引为2的位置，这里返回的索引值不是倒着数元素5所在的索引-3，仍然是索引2。

        // lastIndexOf()
        console.log(d.lastIndexOf(8)); // 返回3，表示元素8在数组d里
        console.log(d.lastIndexOf(3)); // 返回-1，表示元素3不在数组d里

        // 返回-1，表示元素8不在数组索引从-3开始到索引-5结束的这段位置里，因为从后往前查找，索引-5是整个数组结束位置。
        console.log('从后往前查找' + d.lastIndexOf(8, -3));

        // 返回-1，表示元素8不在数组d从索引0开始的位置里，因为从后往前查找，索引0是整个数组结束位置。
        console.log(d.lastIndexOf(8, 0));
        console.log(d.lastIndexOf('pink', 0)); // 返回0，表示'pink'在数组d里索引为0的位置



        // 给数组元素去重，把不重复的元素存到新数组里
        function unique(dd) {
            var ee = [];
            for (var i = 0; i < dd.length; i++) {
                // 判断新数组里有没有旧数组的第i个元素，indexOf的返回值=== -1就是没有此元素。
                if (ee.indexOf(dd[i]) === -1) {
                    // 新数组里没有此元素，将它添加到新数组里。
                    ee.push(dd[i]);
                }
            }
            return ee;
        }
        var dd = ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'];
        console.log(unique(dd));

        // 将数组里相同的元素的索引号输出，并且输出该元素在数组中共有多少个。
        var arr = ['red', 'blue', 'red', 'pink', 'red'],
            num = 0, // 存共多少个的初始变量
            index = arr.indexOf('red'); // 将第一个red元素出现的索引值赋值给index
        // 满足index !== -1表示red元素在arr数组里，但indexOf()方法只查找一次，只要找到第一个red元素就会返回它的索引号，所以需要用循环。
        while (index !== -1) {
            // 先输出每次找到的该元素的索引值。
            console.log(index);
            // 每次循环后的index变量存的索引值都 + 1，作为indexOf()方法的第二个参数，也就是要查找的起始位置索引号。
            index = arr.indexOf('red', index + 1);
            // num变量每循环一次都自加1，来统计red元素出现的次数，得到共多少个red元素
            num++;
        }
        console.log('"red"元素共出现' + num + '次');



        // join()将数组转换成字符串，可以自定义分隔符
        var ee = ['ha', 5, 8];
        console.log(ee.join()); // 得到 ha,5,8 字符串
        console.log(ee.join('-')); // 得到 ha-5-8 字符串
        console.log(ee.join('&')); // 得到 ha&5&8 字符串
        console.log(ee.join('')); // 得到 ha58 字符串,参数直接传''会将元素之间的分隔符去掉

        //concat()合并数组，不改变原数组，返回合并后的新数组
        var ff = [1, 2],
            gg = ['a', 'b'],
            hh = ff.concat(gg); // 得到[1, 2, "a", "b"]，哪个数组调用concat()方法，合并后的新数组里调用数组的元素就在前面位置。
        console.log(hh);
        hh = ff.concat(ff); // 得到 [1, 2, 1, 2]
        console.log(hh);
        console.log(gg.concat(ff)); //得到["a", "b", 1, 2]
        // 这里参数[4,5]没有声明为数组，所以合并时会去掉[]将里面的元素作为新数组的元素
        console.log(gg.concat('我爱你', 3, [4, 5])); //得到["a", "b", "我爱你", 3, 4, 5]
        var ii = ['我爱你', 3, [4, 5]];

        // 返回值新数组里是有嵌套数组的，["a", "b", "我爱你", 3, [4, 5]]。
        console.log(gg.concat(ii)); // 得到["a", "b", "我爱你", 3, Array(2)]

        // slice()截取数组的某些元素组成新数组，不会改变原数组，返回截取的元素组成的新数组
        var kk = [1, 2, 3, 4, 5, 6];
        console.log(kk.slice()); //得到[1, 2, 3, 4, 5]，不传参数截取整个数组
        console.log(kk.slice(2)); //得到[3, 4, 5]，参数2是从索引为2的位置开始截取数组到数组结束
        console.log(kk.slice(2, 4)); //得到[3, 4]，从索引2的位置开始截取到索引4的位置结束(不含)

        //splice()删除或替换或添加数组元素，改变原数组，返回删除或替换下来的元素组成的数组
        var ll = [1, 2, 3, 4, 5, 66];
        var k = kk.splice(); // 要求必需传至少一个参数，这里没有报错，也没有对原数组进行任何操作，返回值是空数组。
        console.log(k);
        console.log(kk);
        // 给原数组添加元素，方法的返回值是[]。
        removde = ll.splice(1, 0, 'red');
        console.log(ll); // 原数组变成[1, "red", 2, 3, 4, 5, 66]

        // 给原数组替换元素，原数组从索引1开始，删除两个元素（含索引1的元素），将删除的元素替换成'blue', 7, 8。返回值是删除的两个元素组成的数组['red',2]
        removde = ll.splice(1, 2, 'blue', 7, 8);
        console.log(ll); // 原数组变成[1, "blue", 7, 8, 3, 4, 5, 66]

        // 给原数组删除元素,从原数组索引3开始，删除1个元素，所以删除的是索引3对应的元素。
        removde = ll.splice(3, 1);
        console.log(ll); // 原数组变成[1, "blue", 7, 3, 4, 5, 66]

        // 给原数组删除元素,只传一个参数，表示从原数组索引3开始，删除包括索引3和它后面的所有数组元素。
        removde = ll.splice(3);
        console.log(ll); // 原数组变成[1, "blue", 7]
    </script>
</head>

<body>

</body>

</html>