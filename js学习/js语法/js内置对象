查js的各种内置对象库：
    MDN网址：
        https://developer.mozilla.org/zh-CN
        
js对象分为3种：
    浏览器对象；
        浏览器对象属于js独有的；

    以下两种对象属于js的基础内容，属于ECMAScript；
        自定义对象：
            通过{}表示的；

        内置对象；


js常用的几个内置对象如下：

数字和日期对象：
    用来表示数字、日期和执行数学计算的对象，有4种：

        Number是内置的数字构造函数，调用需要前面加new；
            Number.toFixed() 
                对浮点数进行四舍五入精度获取,保留参数位小数。
                参数:
                    需要保留的小数位数
                返回值:
                    一个带有参数位的浮点数
            问题：直接使用会出现异常的舍入情况,得到的值不一定正确。
            原因：计算机浮点数存储是二进制，js的Number.toFixed()实际的精度确认规则是四舍六入五成双，逢四下舍，逢六入一，逢五时，根据浏览器内核计算结果也不尽相同。


        BigInt是内置的最大整数构造函数，调用方法是通过new 操作符；

        Math是一个内置对象，它拥有一些数学常数属性和数学函数方法。

        Math部分方法：
            Math.abs(x)
                求参数数值的绝对值；
                返回值：
                    一个正整数,
                    正数的绝对值是它本身，
                    负数的绝对值是把负号去掉的数值；
                    不传参数返回NaN;
                    传入一个非数字形式的字符串或者 undefined/empty 变量，将返回 NaN。
                    传入 null 将返回 0。

            Math.max([x[, y[, …]]])
                返回值：
                    给定的一组数字中的最大值,参数只能一个个写到括号里；
                    如果给定的参数中至少有一个参数无法被转换成数字，则会返回 NaN。
                    如果没有参数，则结果为 - Infinity。
            
            Math.min([x[, y[, …]]])
                返回值：
                    给定的一组数字中的最小值,参数只能一个个写到括号里；
                    如果给定的参数中至少有一个参数无法被转换成数字，则会返回 NaN。
                    如果没有参数，则结果为 - Infinity。

                用强制改变this执行的apply()方法的第二个参数是数组,可以实现max和min方法可以传一个数组作为参数,不用再将参数一个个写到括号里,
                实现原理是:调用apply方法的第二个参数数组里装的都是 调用方(也就是原函数)的参数;
                写法:
                    var arr = [1,2,3,4];
                    Math.max.apply(null,arr); 
                    Math.min.apply(null,arr);
                    
                    注意:
                        apply第一个参数传null是因为不需要用它的改变this执行的功能;

            Math.pow(base, exponent)
                幂运算，第一个数的第二个数次方；
                返回值：
                    返回基数（base）的指数（exponent）次幂的运算结果；
                    不传参数和一个参数都返回NaN。

            Math.random()
                生成一个0-1之间的随机数，采用左闭（包括0）右开（不包括1）区间，
                没有参数，括号里不能写参数。
                生成机制是：
                    "四舍六入五取偶"
                “五取偶”的规则：
                    当小数部分恰为0.5时，若个位是奇数则入，若个位是偶数则舍，总之让个位变成偶数。

                返回值：
                    一个浮点型伪随机数字，在0（包括0）和1（不包括）之间；
                
                得到一个两个数之间的随机数：
                    function getRandomArbitrary(min, max) {
                        return Math.random() * (max - min) + min; 
                    }
                
                得到一个两个数之间的随机整数：
                    function getRandomInt(min, max) {
                        //不含最大值，含最小值
                        return Math.floor(Math.random() * (max - min)) + min; 
                    }


            Math.sqrt(x)
                给一个数值开平方；
                参数x是运算结果的2次方，也就是两个相同的运算结果相乘等于参数。
                返回值：
                    一个数的平方根。
                    如果参数 number 为负值，则 sqrt 返回NaN。-0除外，-0开平方结果是-0；

        取整的四个方法：

            Math.ceil(x)
                将给定参数数值向上取整；
                返回值：
                    大于或等于一个给定数字的最小整数。
            Math.floor(x)
                将给定参数数值向下取整；
                返回值：
                    小于或等于一个给定数字的最大整数。
            Math.trunc(value)
                方法会将数字的小数部分去掉，是删除掉数字的小数部分和小数点，不管参数是正数还是负数，只保留整数部分；
                返回值：
                    一个数的整数部分。
            Math.round(x)
                将一个数值四舍五入成整数,只看小数点后的一位来决定是舍还是入；
                如果参数数值的小数部分是0.5,则返回离参数数值最近的大的那个值；
                所以-0.5，返回-0，它在0和-1之间取大的值，因为0比-1大，-号不会丢掉所以是-0。
                返回值：
                    四舍五入后的整数。
        Math.PI 
            就是数学中的那个 π , 3.1415926...;
            1π = 180°;
            
        
        Math.sin(x)
            返回一个数x的正弦值;
            返回值在 -1.0 到 1.0 之间；

        Math.cos(x)
            返回 一个数x的余弦值;
            返回的是 -1.0 到 1.0 之间的数；

            这两个函数中的参数X 都是指的“弧度”而非“角度”，
            
            弧度的计算公式为： 1弧度 = Math.PI / 180角度； 1弧度大概是50°-60°左右的角; 
            角度转弧度：2π / 360  = π / 180 ≈ 0.0174rad, 即: 弧度=角度*(Math.PI/180);
                例如：将30º转为弧度rad 
                    30° * (π / 180）= 0.523320rad (弧度数学中叫rad) 
            弧度转角度: 360 / 2π  = 180 / π ≈ 57.3º,  即: 角度=弧度*(180/Math.PI);
                例如：将0.523320rad转为角度°
                    0.523320rad * (180 / π) = 29.9992352688º 

  
        Date是处理日期时间的对象，是构造函数，创建一个新Date对象的唯一方法是通过new 操作符。
        语法：
            var date = new Date();
            如果没有提供参数，返回系统的当前日期和时间，返回结果是字符串类型。

            参数：
                1.传0返回1970年0点那个时间,
                2.参数为数字类型，参数间用,隔开，返回结果是字符串类型；
                    按照顺序分别传入 年、月、日、时、分、秒、毫秒，
                    数字类型的参数得到的月份会比传入的月份小一个月，必需在后面+1才能得到正确的月份。因为国外的月是从0开始的，js是外国人开发的，所以Date对象的月份是从0开始，11结束的。

                参数为字符串类型，3种写法：
                    1.'年-月-日 时:分:秒'，返回参数传的日期和时间，返回结果是字符串类型。
                    2.'年/月/日 时:分:秒', 返回参数传的日期和时间，返回结果是字符串类型。

        部分方法：
            getFullYear()
                获得当前年份，返回数字类型
            getMonth()
                获得当前月份，返回数字类型；
                构造函数Date()的月份是0-11,所以想要得到正确的当前月份,必需写成getMonth() + 1 。
            getDate()
                获得当前日，返回数字类型。
            getDay()
                获得当前星期，返回数字类型,星期0~6,0表示星期日。
            getHours()
                获得当前小时，返回数字类型。
            getMinutes()
                获得当前分钟，返回数字类型。
            getSeconds()
                获得当前秒钟，返回数字类型。
            getMilliseconds()
                获得当前毫秒数,返回值是 0 ~ 999 之间的一个整数.

        获得Date总的毫秒数（millisecond，也叫时间戳），是从1970年1月1号(世界标准时间,是纪念linux系统创始人的)00:00:00到当前时间的总毫秒数，4种方式：
            第一种：
                getTime()
                
            第二种：
                valueOf()

            第三种最常用，直接在new操作符前面写个 + 号,
            js在某个数据类型前使用‘+’，这个操作目的是为了将该数据类型转换为Number类型，如果转换失败，则返回NaN;
            +new Date()是简写，实现原理：会调用Date.prototype 的 valueOf方法实现转换时间戳。
            语法：

                var 变量名 = +new Date();

            第四种:
                Date.parse(日期对象);
                    必需传个日期对象作为参数,不传参数返回NaN.

            第五种是h5新增的，要考虑浏览器的兼容性：
                Date.now()
                
            这五种方式都是：
                不传参数返回截止当前时间的总毫秒数；
                前4种传入时间参数，则返回传入时间到1970年1月1号的总毫秒数。但不精确，后面好多个0；
                第5种没有参数，不能传参数。

        setTime(毫秒数)
            重置1970年至参数传入的毫秒数,返回参数转换后的日期时间

        setTimeout(函数,毫秒数)
            延时器,用来指定某个函数或字符串在指定的毫秒数之后执行,也就是第二个参数长的时间后调用执行第一个参数,
            参数,2个:
                第一个参数,2种:
                    1.字符串,但会造成javascript引擎两次解析，降低性能，故不建议使用;
                    2.函数(外面封装的函数/匿名函数/箭头函数);
                第二个参数:
                    毫秒数(默认值是0),这个毫秒时长后就会调用执行第一个参数;
            返回值:
                一个整数，表示定时器的编号，这个值可以传递给clearTimeout()用于取消这个函数的执行;
            注意:
                setTimeout() 只执行一次函数。如果要多次调用，请使用 setInterval() 或者让 函数 自身再次调用 setTimeout();

        setInterval(函数,毫秒数)
            定时器,每隔第二个参数的时间,执行一次传入的函数;
            setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或这个js文件窗口被关闭;
            语法:
                setInterval(function(){
                    执行代码体...
                }, 毫秒数)
            参数,2个:
                第一个参数:
                    传入外面封装好的函数,函数名不能带括号;或直接在括号里写匿名函数
                第二个参数:
                    传入多久调用一次参数一函数的时间
            返回值:
                启动定时器的系统分配的编号,相当于人的出生证明.

        clearInterval(接收定时器返回值的变量)
            按定时器的编号停止定时器

        toUTCString()
            将一个时间对象转换成世界时间格式的字符串,没有参数,返回值是字符串


        时间戳转换成天、时、分、秒 的公式：
            总秒数 = millisecond毫秒 / 1000;    将时间戳换算成总秒数
            day = parseInt(总秒数/60/60/24);    计算天数
            hours = parseInt(总秒数/60/60%24);  计算小时数
            minutes = parseInt(总秒数/60%60);   计算分钟数
            seconds = parseInt(总秒数%60);      计算秒数

            它们在表示时间的长度上是相等的，等号前面的等于等号后面的 ：
                总秒数 = 天数 + 小时数 + 分钟数 + 秒数;

        



Array数组对象：

    length属性：
        作用：
            返回或设置一个数组中的元素个数。
        返回值：
            数字类型，取值范围：是一个 0 到 2的32次方-1 范围内的整数，
            （2的32次方 = 4294967296）。

    Array.from(伪数组)
        将伪数组转换成真数组;ECMA6新增的方法.
        返回值:
            转换后的真数组;

    检测是否为数组类型，两种：
        instanceof运算符
            判断一个实例是否属于某种类型,可以判断任何类型,不止用在判断数组;
            更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型;
            语法:
                变量 instanceof Array;
            作用：
                检测某个变量的值或其它数值是不是数组类型
            返回值：
                是数组类型返回true；
                不是数组类型返回false。
        isArray()方法
            检测某个变量的值或其它数值是不是数组类型，
            是h5新增方法，IE9以上浏览器支持，优先级比Instanceof高。
            返回值：
                是数组类型返回true；
                不是数组类型返回false。

    给数组新增加元素的方法，两种：
        unshift(items...)
            在原数组的开始增加新的数组元素，
            参数可以传1个或多个。
            返回值：
                新数组的长度，是数字类型。
        push(items...)
            在原数组的末尾增加新的数组元素，
            参数可以传1个或多个。
            返回值：
                新数组的长度，是数字类型。

    删除数组的元素的方法，两种：
        shift()
            删除数组的第一个元素，一次只能删除一个元素。
            没有参数，括号里不能写参数。
            返回值：
                删除的那个元素，
                删除的那个元素是什么数据类型，就返回什么数据类型。
        pop()
            删除数组的最后一个元素，一次只能删除一个元素。
            没有参数，括号里不能写参数。
            返回值：
                删除的那个元素，
                删除的那个元素是什么数据类型，就返回什么数据类型。

    reverse()
        翻转数组的元素，将数组中元素的位置颠倒，数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。会改变原数组。
        没有参数，括号里面不能写参数。
        返回值：
            返回颠倒后的数组。

    sort()
        给数组里的元素进行排序，
        默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。

        参数：
            1.不传参数，数字类型的元素默认从小到大排序,
                并且只能对一位数的数字进行排序，两位数以上的数字的需要用下面的函数来实现正确的排序。
            2.不传参数，字符串类型的元素默认从a-z排序;

            3.可以写 =>箭头函数（匿名函数）,语法有2种：
                1.参数 => 运算表达式;
                    运算表达式：a - b; 升序； 或者 b - a; 降序。
                2.参数 => {
                    函数体...
                    return 返回值
                }
                如果参数不止一个，就需要用括号()括起来，
                如果函数返回值是一个对象，需要将{}外面写（）包起来；
            4.可以写函数，2种：
                function (a, b) {
                    return a - b;    升序排序
                }
                function (a, b) {
                    return b - a;   降序排序。
                }
                注意：
                    这个函数是固定写法，
                    函数的参数是固定的个数，就两个，表示两个将要进行比较的元素。
                    
        返回值：
            排序后的数组。
            直接改变原数组，而不是创建新的排序后的数组。数组已原地排序，并且不进行复制。

    find() ECMA6新增的方法
        在数组中查找符合条件的元素,只要找到第一个符合条件的元素,就停止遍历数组;
        语法:
            find(function(item, index, arr) {
            return 查找条件;
        })
            用箭头函数简写,例如: find(item => item > 20); 
        返回值:
            找到的元素;
    
    findIndex() ECMA6新增的方法
        和find()一样的用法,在数组中查找符合条件的元素,只要找到第一个符合条件的元素,就停止遍历数组,如果是空数组,此方法不会执行;
        返回值:
            找到的元素的下标;
            如果没有符合条件的元素,就返回-1;

    copyWithin() ECMA6新增的方法
        替换数组元素,将数组中的元素从参数2至参数2这个范围拷贝,插入到参数1处,并从参数1处开始覆盖拷贝范围的长度个元素;
        参数,3个:
            第一个:从哪个下标开始插入并向后覆盖;
            第二个:从什么位置开始拷贝的索引号;
            第三个:结束拷贝的索引号,不含;
        返回值:
            替换后的新数组;
            例如:
                var arr = [1,2,3,4,5,6,7,8];
                arr.copyWithin(2, 5, 7); 
                参数一是从索引为2的元素开始插入替换,
                参数二和三是从索引5的元素开始拷贝,到索引7的元素结束,不含索引7的元素,那就是拷贝了索引5和索引6这位置的2个元素,
                将这2个元素插入到第一个参数索引2的位置,覆盖索引2和索引3位置的元素,拷贝几个元素,就会在插入位置开始覆盖几个元素;
                得到1,2,6,7,5,6,7,8这个新数组;

    indexOf()
        判断一个元素在不在数组里面（元组在数组里第一次出现的位置），从数组的开始位置开始查找。
        实现原理是：
            返回值是否=== -1来判断此数组里是否包含传入的参数元素。
        写法：
            数组名.indexOf(要查找的元素,从索引为几的位置开始查找);
        参数，两个，用,隔开，第二个参数可选：
            1.要查找的元素，
            2.索引号，索引号表示指定开始查找的位置：
                如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1；
                不管参数是正值还是负值都是从前往后查找，
                如果参数中提供的索引值是一个负值，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。
                注意：
                    如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组,返回值仍然是正的索引号。
                    例如：一个数组有3个元素，当前元素在索引倒着数为-3的位置，从-3开始查找，它查找的顺序依然是会从前往后，-3、-2、-1结束，返回值是当前元素的索引号为正着数的0。

                    如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0.
        返回值：
            返回数组中该元素第一次出现位置的索引号，
            如果不存在，则返回-1。

    lastIndexOf()
        判断一个元素在不在数组里面，从数组的结束位置开始往前查找，也就是从尾到头查找。

        写法和indexOf()一样，参数也是两个，
        区别是：
            不管第二个参数正值或负值都是从后往前查找，返回值仍然是正的索引号；
            如果该值为正值，大于或等于数组的长度，整个数组会被查找；
            如果该值为负时，其绝对值大于数组长度，数组不会被查找，返回 -1，
            例如：
                数组长度5，lastIndexOf()第二个参数是-6，就会不查找直接返回值-1，
                因为-6的绝对值是6，表示该索引值比数组长度大。

        返回值：
            数组中该元素最后一次出现的索引，
            如未找到返回-1。
    
    总结：
        返回值都是从前往后数的元素所在位置索引号。
        当数组（字符串）中所要查询的数（字符串/字符）在字符串（数组）中只出现一次的时候，二者返回的索引值相同；
        当数组（字符串）中所要查询的数（字符串/字符）在字符串（数组）中出现两次及以上的时候：  
　　　　　　indexOf  返回的是 valuesearch 第一次在数组（字符串）出现的位置（从左往右）；
　　　　　　lastIndexOf 返回的是 valuesearch 最后一次在数组（字符串）出现的位置（从右往左）；


    内置遍历数组的方法，是ECMA5新增的方法，IE8及其以下浏览器均不兼容。共7种：
        forEach()
            遍历数组，（和for循环、for..in循环一样的效果），可以通过循环体的代码，改变原数组。
            参数：
                是一个函数，函数里有3个参数。
            语法：
                数组名.forEach(function(item, index, 数组名) {
                    循环体代码... 
                    例如：数组名[index] = item *2; 表示将原数组的每个元素*2，计算后再将结果作为元素，存到原来的数组当前索引为index的位置。
                });
                函数的3个参数：
                    item 表示当前遍历到的元素
                    index 表示当前遍历到元素的索引
                    数组名 表示数组本身.
            返回值：
                无返回值。
                
        map()
            遍历原数组，return那里写遍历原数组要做的事情，将结果赋值给变量生成新数组，与原数组形成一种映射关系，不改变原数组，
            新数组里的元素是return的返回值；

            语法：
                新数组 = 数组名.map(function(item, index, 数组名) {
                    return 循环体代码..;  
                    例如：return item + 1; 原数组的元素都+1后按原数组里元素的索引位置存入新数组对应的索引位置。
                });
                也可以简写,把参数写成箭头函数:
                   新数组 = 数组名.map(item => item + 1); 

            返回值：
                返回处理后的新数组。
            
        
        filter()
            遍历数组，用于筛选数组中满足条件的元素，返回一个筛选后的新数组，
            过滤符合return后面的条件的所有元素，赋值给变量生成新数组，不改变原数组，
            语法：
                新数组 = 数组名.filter(function(item, index, 数组名) {
                    return 过滤条件..;  
                    例如：return item > 20; 原数组大于20的元素，都会取出存入新数组
                });
                也可以简写,把第一个参数写成箭头函数:
                   新数组 = 数组名.filter(item => item >20); 

                函数的后两个参数是可选参数。
            返回值：
                返回数组，包含了符合条件的所有元素。
                如果没有符合条件的元素则返回空数组。

        some()
            遍历数组，用于判断数组中的是否存在满足条件的元素，返回一个布尔值，
            查找数组中的元素符合return后面的条件，只要有一个符合返回true，并结束循环，都不符合返回false。
            语法：
                语法：
                数组名.some(function(item, index, 数组名) {
                    return 条件..;  
                    例如：return item > 20; 数组的元素是否有一个大于20的，是返回true，停止循环，否则继续遍历完整个数组，都没有符合return条件的，返回false。
                    如果不是return后面写的表达式执行结果是true,就得直接写return true来停止遍历,节省性能,否则即使找到了符合条件的元素,它还是会继续遍历;
                });
            返回值：
                true；
                false。

        every()
            遍历数组，用于判断数组中的每一项元素是否都满足条件，返回一个布尔值，
            查找数组中的每一个元素是否符合return后面的条件，要求每一个元素都符合条件，才返回true，只要有一个元素不符合直接返回false。
            只要找到不符合条件的元素，就停止循环，返回false，后面不管有多少元素，都不再遍历了。
            语法：
                数组名.every(function(item, index, 数组名) {
                    return 条件..;  
                    例如：return item > 20; 数组的元素是否都大于20，是返回true，否则返回false
                });
            返回值：
                true；
                false。

        总结：
            ① forEach()无返回值，map()和filter()返回新数组，every()和some()返回布尔值
            ② 以上五大方法除了传递一个匿名函数作为参数之外，还可以传第二个参数，该参数用于指定匿名函数内的this指向，匿名函数中this指向默认为window，可通过传第二参数来更改。

        reduce()
            遍历数组，是数组的归并方法，可同时将前面数组元素遍历产生的结果与当前遍历元素进行运算；
            init参数省略时，循环默认从索引1开始遍历。
            语法:
                arr.reduce(function(prev,cur,index,arr){
                    return 遍历原数组需要做的事情;
                        例如：return perv + cur; 
                            这里perv第一次循环时存的是索引为0的元素，第二次循环时存的是return条件的返回值，也就是索引为0的元素+索引为1的元素的和；后面每次循环存的都是return的返回值，
                            cur第一次循环时存的是索引为1的元素，第二次循环时存的是索引为2的元素...。
                    }, init);

                参数：
                    prev 表示上一次调用回调时的返回值，或者初始值 init;
                    cur 表示当前正在处理的数组元素；
                    index （可选） 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；
                    arr （可选）表示原数组；
                    init（可选）表示初始值。
            返回值:	
                返回计算结果。

        reduceRight()
            该方法用法与reduce()其实是相同的，只是遍历的顺序相反，它是从数组的最后一项开始，向前遍历到第一项。


    join('分隔符')
        将数组转换成字符串类型。
        参数：
            不传参数，元素默认用,隔开。
            参数直接传''会将元素之间的分隔符去掉；
            参数用''引起来，引号里面可以自定义任何符号，作为转换后字符串的分隔符。
        返回值：
            字符串

    concat() 
        用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组，
        还有一个功能：
            拷贝原数组，生成有同样元素，但在内存中地址不同的新数组，它们不再指向同一内存地址存的元素。
        语法：
            新数组名 = 调用此方法的要合并的数组1.concat(要合并的数组2,...要合并的数组n,元素1..);
        参数，一个或多个：
            可以直接传元素，
            可以传数组，传的数组会先被拆成每个元素再进行合并，
            可以传嵌套的数组，
        返回值：
            合并后的新数组。
            调用concat()方法的数组，里面的元素，在合并后的新数组里排在最前面。

    slice() 
        截取数组中的元素，返回一个新的数组对象，原始数组不会被改变。
        这一对象是一个由参数 begin 和 end 决定的（包括 begin，不包括end）。
        （和python的列表切片一样,头下标和尾下标，只是没有步长。）

        参数，两个，用,隔开，第二个是可选参数：
            第一个参数：
                是截取起始处的索引（从 0 开始），从该索引开始提取原数组元素。
                如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。
                如果省略第一个参数begin，从索引 0 开始截取。
                如果 begin 大于原数组的长度，则会返回空数组。
            第二个参数：
                是截取终止处的索引，不包含结束索引，
                如果 end 被省略，则 slice 会一直提取到原数组末尾。
                如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。
        返回值：
            由截取的元素组成的新数组。

    splice() 
        通过删除、替换（先删除再修改）现有元素、原地添加新的元素来修改数组,并以数组形式返回被修改的内容。
        此方法会改变原数组。
        如果添加进数组的元素个数不等于被删除的元素个数，数组的长度会发生相应的改变。

        参数，一个或多个：
            第一个参数：
                开始位置的索引，指定修改的开始位置（从0计数）。
                如果第一个参数值超出了数组的长度，则从数组末尾开始添加内容；
                如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；
                如果负数的绝对值大于数组的长度，则表示开始位置为第0位。
            第二个参数，可选：
                整数，表示要截取的元素的个数。
                如果省略，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除，（含第 start 位）。
                如果是 0 或者负数，则不移除元素。这种情况下，应该写第三个参数，添加一个新元素。
            第三参数，一个或多个，可选：
                是要添加或替换进数组的元素，从 第一个参数开始，个数是第二个参数个元素，
                如果不指定第三参数，splice()方法将只删除数组元素。

            返回值：
                由被删除的元素组成的一个数组。
                如果只删除了一个元素，则返回只包含一个元素的数组。
                如果没有删除元素，则返回空数组。
                这个只了解一下：
                    如果调用splice()方法时没传任何参数，就表示没有对原数组进行任何操作，返回一个空数组，但splice()方法要求必需传一个参数。

        

字符串对象：
    String
        只有复杂数据类型才有属性和方法，所以js将字符串包装数据类型，使它也有属性和方法。
        字符串是不可变的，所以字符串的所有方法和属性，都不会修改字符串本身，操作完成后只会返回一个的新字符串。

            length属性：
                查看字符串的长度
                返回值：
                    字符串的长度数值，是数字类型。

        判断字符或字符串是否在另一个字符串中,5种方法：
            indexOf('要查找的字符或字符串','从什么位置开始查找的索引号')
                判断字符或字符串是否在字符串中（在另一个字符串中第一次出现的位置），
                从第二个参数位置开始查找，第二个参数是可选参数，不传默认从索引0开始查找，从前往后查找，
                和数组对象的indexOf()一样作用，参数返回值都一样。
                返回值：
                    字符在字符串中，就返回该字符所在位置的索引，
                    字符不在字符串中，返回-1。
            lastIndexOf('要查找的字符或字符串','从什么位置开始查找的索引号')
                从后往前查找，和数组对象的lastIndexOf()方法一样。     
            search()
                判断字符或字符串是否在字符串中（在另一个字符串中第一次出现的位置），
                参数，一个：
                    字符串或正则表达式。
                返回值：
                    字符在字符串中，就返回该字符所在位置的索引，
                    字符不在字符串中，返回-1。
            includes()
                判断一个字符串是否包含在另一个字符串中，对字符串的大小写敏感。
                参数，两个：
                    第一个参数：
                        要在此字符串中搜索的字符串。
                    第二个参数，可选：
                        从当前字符串的哪个索引位置开始搜寻子字符串，默认值为 0。
                返回值： 
                包含返回 true 
                不包含返回 false。
            match()
                在字符串内检索指定的值，或找到一个或多个匹配的子串或字符;
                参数:
                    如果是字符或字符串,返回第一个匹配的;
                    如果是正则表达式,不写修饰符g,只返回第一个匹配的,写修饰符g会返回整个字符串里的匹配项;
                返回值:
                    匹配成功,返回一个数组,装匹配到的子串;
                    匹配失败,返回null;

        取出字符串指定位置的字符，根据索引位置返回字符，2种方法：
            charAt(索引号)
                根据索引查找字符串中的字符，参数传的什么索引号就返回该索引位置对应的字符。
                参数：
                    索引号，在0-arr.length-1之间的数字。
                    不传参数时默认值是索引0。
                    参数没有负索引，不能传负值，不报错，但返回空字符串。
                返回值：
                    参数索引位置所对应的字符。
                    参数超出了取值范围，会返回一个空字符串。
            存字符串值的变量名[索引号]
                是h5新增的方法，将字符串看做数组一样用 [索引号] 操作，
                有兼容性问题，和charAt()方法一样的作用，参数、返回值都一样。

        和ASCII码有关的：
            ASCII码表是什么：
                电脑内部每个字符和字符对应的编码的一张表，电脑存储每个字符用的是二进制数，为了阅读方便，ASCII码表将字符对应的二进制数转换成十进制数，显示给用户。
                就像给一个人取名字，通过名字找到他，或者像给一个东西编个序号，通过序号找到它。
            charCodeAt(索引号)
                根据索引查找字符串中的字符，参数传的什么索引号就返回该索引位置对应的字符的ASCII码。              
                参数：
                    一个大于等于 0，小于字符串长度的整数。
                    如果小于 0 、等于或大于字符串的长度，则 charCodeAt 返回 NaN。
                    如果不是一个数值，则默认为 0。
                返回值：
                    参数索引位置所对应的字符的ASCII值。
                    返回值范围是 0 到 65535 之间的整数，表示给定索引处的 UTF-16 代码单元。
                    如果 index 超出返回值范围，charCodeAt() 返回 NaN。
                    键盘上的不管是数字或字母或特殊符号，都有一一对应的ASCII码。
                    作用场景例如：
                        以后开发中主要用于游戏等应用，根据返回值是字符所对应的ASCII码，判断用户按下了键盘上的哪个键，从而来控制是前后移动还是跳跃等。。例如小写字母a对应的ASCII码是97。
            fromCharCode(ASCII码1,ASCII码2....)
                将传入的ASCII码值转换成对应的字符，生成一个字符串。
                参数：
                    可以传多个参数。
                返回值：
                    转换后的字符组成的字符串。
            
        concat(str1,str2....)        
            连接、拼接两个或多个字符串，
            如果参数不是字符串类型，它们在连接之前将会被转换成字符串。
            和数组的concat()方法一样，
            作用等价于 +号拼接字符串，建议使用 + 来连接字符串，更方便常用。
        
        截取字符串的方法，3种：

            substr(start,length)
                截取字符串中的某一段字符，这个方法快废弃了，尽量不要用。
                参数：
                    第一个参数表示开始截取位置的索引号，
                    第二个参数表示截取的个数。
                返回值：
                    截取到的字符组成的新字符串
            substring(start,end)
                截取字符串中的某一段字符
                参数：
                    第一个参数表示开始截取位置的索引号，
                    第二个参数表示结束截取位置的索引号，不含。
                    如果任一参数小于 0 或为 NaN，则被当作 0。
                    如果任一参数大于 stringName.length，则被当作 stringName.length。
                    如果 Start 大于 End，则 substring 的执行效果就像两个参数调换了一样。
                    如果 Start 等于 End，则 返回空字符串''。

                返回值：
                    截取到的字符组成的新字符串
            slice(start,end)
                截取字符串中的某一段字符，这其实是数组的方法，可以被字符串使用。
                参数：
                    第一个参数表示开始截取位置的索引号，
                    第二个参数表示结束截取位置的索引号，不含。
                返回值：
                    截取到的字符组成的新字符串

        replace('需要替换的字符','替换为的字符')
            替换字符串中的字符。
            参数：
                第一个参数：
                    表示需要替换的字符，
                    也可以是一个字符串或者一个正则表达式,用来匹配想要替换的内容；
                    如果是字符或字符串，则仅替换第一个匹配项，也就是说一个字符串中有多个相同的字符或字符串时，它只会替换第一个出现的字符或字符串， 调用一次只替换一个字符。
                    如果是正则表达式，匹配到的全部都会被替换，不写修饰符g,替换第一个匹配项,写修饰符g会替换整个字符串里的匹配项;
                    正则书写：/字符串/，还有两个修饰符：i 忽略大小写，g 全局匹配。
                第二个参数：
                    表示替换为的字符，用来替换掉第一个参数匹配到的内容
                    也可以是一个字符串或者一个每次匹配都要调用的回调函数,回调函数的返回值作为替换为的字符串。
                        匿名函数有4个参数可以传入，当然，这些参数都不是必须要传的。
                        　　第一个参数：正则所匹配到的字符,也就是replace()的第一个参数正则匹配到的第二个参数接收的实参字符；
                        　　第二个参数：捕获到的字符,也就是replace()第一个参数正则表达式里的字符；
                        　　第三个参数：正则匹配到的每段字符的第一个字符的索引；
                        　　第四个参数：用于匹配的字符串主体；
                    
            返回值：
                替换后的新字符串;
                如果没有替换成功,就返回调用方这个原字符串;
        
        split('分隔符')
            将字符串转换为数组,转换后数组里的元素都是字符串类型。
            先用分隔符将字符串分割，再将分割后的子串存入数组中。
            和数组的join()方法作用刚刚相反。
            参数：
                不传参数,将整个字符串作为1个元素,存到数组里;
                第一个参数：
                    字符串里用什么分隔符隔开字符的，split()就传什么分隔符做参数。
                    也可以传字符串或正则表达式(不写修饰符g也全局匹配)。
                第二个参数，可选：
                    一个整数，限定只转换几个字符或字符串（限定返回的分割片段数量）。
                    不写默认是0,
                    写正整数,写几返回几个元素的数组;
                    写负整数,返回没有元素个数限制的数组;
                    例如：一个字符串有5个字符，这个参数写3，就会只把字符串的前3个字符转换成数组元素,这个数组里就只有3个元素。
            返回值：
                转换后的数组，每个字符串字符或子串变成数组的元素，元素之间都自动以,隔开。
                当字符串为空时，split（）返回一个包含一个空字符串的数组，而不是一个空数组，
                如果字符串和分隔符都是空字符串，则返回一个空数组。

                注意：
                    1.几种会产生空字符串的情况:
                    相邻的两个分隔符:
                        例如："a  b c"用" "空格分割，字符a和b之间有两个空格，就会有一个空字符串产生，因为输出时空字符串不显示""，所以会看到数组里元素后面多一个,号，返回的数组是[a,,b,c]。
                    当原始字符串匹配过一次分隔符之后，紧接着，字符串的下一个位置还匹配分隔符:
                        例如：'abbbc'.split('b')，'abbbc'.split(/(b){1}/)
                    字符串开头的一个或几个字符匹配分隔符:
                        例如：'abc'.split('a')，'abc'.split(/ab/)
                    字符串结尾的一个或几个字符串匹配分隔符:
                        例如：'abc'.split('c')，'abc'.split(/bc/)
                    此外，当使用正则表达式作为分隔符的时候，返回的结果中还有可能出现undefined:
                        例如：'abc'.split(/(d)*/)
                    
                    2.分隔符是""空字符串，直接将每个字符，单独分割成子串，存在数组里做元素。
                    3.如果用“.”作为分隔的话,必须是如下写法,String.split("\\."),这样才能正确的分隔开,不能用String.split(".");
                    4.如果用“|”作为分隔的话,必须是如下写法,String.split("\\|"),这样才能正确的分隔开,不能用String.split("|");


        toUpperCase()
            将字符串中的小写字符转换成大写，转换整个字符中的小写英文字符
            返回值：
                转换后的新大写字符的字符串
        toLowerCase()
            将字符串中的大写字符转换成小写，转换整个字符中的大写英文字符
            返回值：
                转换后的新小写字符的字符串


RegExp正则表达式对象,共2个方法:
    在字符串中匹配这个正则表达式是否存在:
        test() 
            检测目标字符串与指定模式是否匹配,有部分匹配即可。如果，要整体匹配，正则前后需要添加开头^和结尾$;     
            语法:
                存正则表达式的变量.test('要检查的字符串');
            返回值:
                匹配成功返回true,
                    不加g修饰符,只能够在字符串中匹配一次,返回字符串中第一个与正则表达式相匹配的内容,lastIndex始终为0。
                    加上全局g.会导致下一次的判断，根据上一次匹配成功的下一位的位置查找，不论正则表达式.test() 括号里要检查的字符串内容是否变化;
                否则false,并且lastIndex自动归0;

        exec()
            检测目标字符串与指定模式是否匹配，并获取匹配结果,
            和字符串的match(rgExp)方法作用类似,都是要返回匹配到的结果,
            但全局模式下,exec()还是只返回一个匹配结果,需要结合循环使用才能得到全部匹配结果;
            字符串match()方法会直接返回全部匹配到的结果; 
            语法:
               存正则表达式的变量.exec('要检查的字符串'); 
            返回值:
                匹配成功返回一个数组,里面装匹配到的子串;
                    不加g修饰符,只能够在字符串中匹配一次,返回字符串中第一个与正则表达式相匹配的内容,lastIndex始终为0。
                    加g修饰符,它每次执行也都只会返回一个匹配项，并且匹配成功后会改变lastIndex的值，值变成匹配结果的下一位索引号,
                        例如字符串'abc',正则/b/g; 要匹配的b在索引1的位置,因为写了全局匹配g,成功匹配b后,lastIndex值是2,是b这个匹配结果的下一位索引号;
                    再次执行的时候，会从lastIndex这个位置开始继续搜索。
                    lastIndex表示的是下一次搜索开始的位置;
                    也可以设置:正则表达式.lastIndex属性=值,让表达式直接从某个位置开始搜索。

                匹配失败,返回null;

                exec方法返回的数组里:
                    第 0 个元素是与正则表达式相匹配的文本;
    　　            第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话）,
                    也就是分组()里的匹配结果;
                    分组的索引从1开始,到有多少个分组,就到多少个元素结束;
                    例如:有5个分组,都匹配成功,那数组从1-6个元素都是分组的匹配结果;
                    接着下一个属性是groups:undefined;这属性值一直是undefined,不知道啥作用??
                    index 属性声明的是匹配文本的第一个字符的位置;
　　                input 属性则存放的是被检索的原始字符串 string;
                    length 属性,值是数组元素的个数;
    　　         
        注意: 
            在创建正则表达式对象时如果使用了“g”标识符或者设置它了的﻿global属性值为ture时，
            也就是在全局模式下,同一个正则表达式,检索任何不同的字符串,调用不同的方法来匹配时,正则表达式的方法都会影响到lastIndex的值。 

            在全局匹配模式下可以对指定要查找的字符串执行多次匹配。每次匹配使用当前正则对象的lastIndex属性的值作为在目标字符串中开 始查找的起始位置。
            lastIndex属性的初始值为0，找到匹配的项后lastIndex的值被重置为匹配内容的下一个字符在字符串中的位置索引，用来 标识下次执行匹配时开始查找的位置。
            如果找不到匹配的项lastIndex的值会被自动设置为0。
            当没有设置正则对象的全局匹配标志时lastIndex属性的值始终为0，每次执行匹配仅查找字符串中第一个匹配的项。
            所以总结出:
                index的记录位置，是根据正则表达式来定的，不同表达式，初始位置都是0，即使验证同一段信息，不同正则表达式，在全局属性下，只要匹配成功,第一次验证结果也都是true或结果文本。
                所以index是和正则表达式规则息息相关的，和验证内容是没关系的。
            尽量不要滥用正则的全局模式;



Object对象:
    Object.assign(要合并的对象1,要合并的对象2....)
        合并对象,将其它参数对象都合并到参数1对象里;
        参数,多个:
            第一个:要合并的对象,合并后会存有所有合并对象的元素;
            第二个:要合并的对象,将所有元素合并到参数1里,
            第三个:要合并的对象,将所有元素合并到参数1里;
        返回值:
            合并后的新对象,都存在参数1里,输出参数1查看;
        例如:
            var obj1 = {
                a: 10
            }
            var obj2 = {
                b:20,
                c:['hello', 5]
            }
            var obj3 = {
                d: function () {
                    return 30;
                },
                e: 60
            }
            将这3个对象合并:
            Object.assign(obj1,obj2,obj3);
            alert(obj1); 
            得到: obj1 = {
                a: 10,
                b:20,
                c:['hello', 5],
                d: function () {
                    return 30;
                },
                e: 60
            }
            此时第一个参数obj1里面装着这3个对象所有的元素,length由1变成了5;
            如果改变obj2对象的简单数据类型b的值,例如:obj2.b = 33; obj1里的b不会变,因为简单数据类型合并时是拷贝的是键和值;
            如果改变obj2对象的复杂数据类型c的其中一个元素,例如:obj2.c.push('word');给c数组的末尾添加一个元素, 这时obj1里的c数组跟着变,因为复杂数据类型合并时拷贝的是内存空间的地址,这是浅拷贝;
            

    Object.create(被当做构造函数的那个对象名,[propertiesObject])
        使用现有对象作为新创建的对象的原型(构造函数)来创建新对象;
        这种方法比 构造函数创建对象 简单，但是不能实现私有属性和私有方法，实例对象之间也不能共享数据;
        参数,2个:
            一.被当做构造函数的原型对象;
            二.可选,如果未指定undefined，新创建的对象默认拥有原型对象的可枚举的属性（在原型对象里定义的那些属性，而不是原型对象继承来的属性,继承来的属性不可枚举）;
        返回值:
            具有指定原型对象和属性的新对象;


    修改属性描述符或给对象新增属性,2种方法:
        Object.defineProperty(对象名, '属性名', {描述符对象})
            直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
            参数,3个:
                一: 要修改属性或添加属性的那个对象;
                二: 对象的一个要修改或新增的属性名;
                三: 一个对象,{}里面是属性的4个特性,
                    如果不指定configurable, writable, enumerable ，则这些属性默认值为false，
                    如果不指定value, get, set，则这些属性默认值为undefined;
            返回值:
                新增了属性的对象,或修改了属性的属性类型的对象;
            例如:
                let obj = { foo: 123 };  
                Object.defineProperty(obj, "foo", {
            　　　　configurable: false,
            　　　　enumerable: true,});
                            
        Object.defineProperties(需要定义或修改属性的某个对象,{要添加或修改的属性})
            直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。
            参数2个:
                一:要修改属性或添加属性的那个对象;
                二:要添加或修改的属性,得写成对象类型,属性是键,{}里面是属性的设置和属性值,属性值必须通过属性的2种类型中的一种来添加,默认是访问器类型,
                    2种属性类型有的那些属性都可以作为{}里的键,
                    但value/writable 和 get/set 不能同时作为键,会报错,因为value/writable是数据属性里的,get/set是访问器属性里的;
                    如果get做键,该函数的返回值将用作该属性的值,默认返回值是undefined。
            返回值:
                新增了属性的对象,或修改了属性的属性类型的对象;
                也就是将第二个参数添加或修改的属性和值,传递给第一个参数对象。
            例如:
                const object1 = {};  声明一个空对象;
                Object.defineProperties(object1, {
                    property1: {  添加一个名字叫property1的属性;
                        value: 42, 添加属性的值是42;
                        writable: true  设置属性的值可以修改;
                    },
                    property2: {}  添加一个名字叫property2的属性,和第一个属性之间用,隔开;
                    });

                    console.log(object1.property1); 输出object1对象的property1属性的值;
        
    获取对象的属性描述符,2种方法:
        Object. getOwnPropertyDescriptor(要查找的目标对象名, '对象的属性名')
            获取一个属性的属性描述符;
            返回值:
                返回指定对象上一个自有属性对应的属性描述符。
                （自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
        Object. getOwnPropertyDescriptors(要查找的目标对象名)
            获取目标对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。
            返回值:
                一个对象,{}里面是目标对象的所有自身属性和属性的描述符;
                如果这个对象没有自身属性,就返回空对象;