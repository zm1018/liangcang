<!-- 布局就是用css来摆放盒子，把每个盒子摆放到相应的位置
css提供了3种传统布局方式（就是盒子如何进行排列)
1.普通流（标准流/文档流）：按照标签自带的默认排列方式排列，多个块级元素纵向排列用标准流。
2.浮动：主要作用：实现多个块级元素横向排列用浮动，盒子之间紧挨着，没有空隙。
    改变元素类型也能实现横向排列，但那种自带有缝隙。
    浮动的特性：1.浮动元素会脱标（脱离标准流）（脱离标准流的控制(浮)移动到指定的位置(动)。
               2.浮动的盒子不再保留原先的位置，后面的标准流会自动占有浮动盒子原先的位子，会产生重叠效果。
               3.浮动的元素会一行内显示，并且都是顶部对齐的，如果父元素装不下多个浮动盒子，一行放不下时，浮动元素只参考它的上一个元素换行排列。
               4.浮动元素具有行内块元素的特性，所有标签加浮动后都可以实现此特性。（排在一行，可以设置宽高等等。。。）
               5.浮动的盒子只会影响它后面一个标准流，而不会影响它前面一个标准流

               6.父盒子很多情况下不方便给高度，没设置高度的父盒子有这种现象：子盒子不浮动时子盒子有多高，父盒子就会被撑大变成一样高，但子盒子设置浮动后不占位置，此时父盒子高度也会变为0，下面的标准流盒子本应正确在下一行显示，但因这个父盒子高度为0 ，下面的标准流盒子就会自动填补上来，影响布局，所以要清除浮动。

               清除浮动方案：
               clear属性只对块元素有效。
               1.用clear：both;清除浮动。谁不想被影响就给谁写清除，这样0高度的父盒子高度又恢复了，子盒子多高，父盒子就被撑多高了，适用上下排列的元素。

               2.给父元素写overflow:hidden;清除浮动，缺点是溢出的部分不显示

               3.给父级写after伪元素清除浮动（类似于额外标签法的升级版，也是在浮动的后面加一个标签来实现的，after伪元素一般写在css代码最上面，起个类名叫clearfix，后面谁需要清除，父元素可以直接调用类名就行了，适用嵌套的元素。
               after伪元素写法：.clearfix:after（后面的意思） {
                                    content: "";
                                    display: block; (因为默认添加行内元素，所以要转换类型)
                                    height: 0;
                                    clear: both;
                                    visibility: hidden;
                                 }
                                 clearfix {
                                     *zoom: 1; （这是为了让低版本IE6、7浏览器支持after）
                                 }

               4.双伪元素清除浮动，使用方法和上面一个一样，也是给父级写，给浮动元素前后都添加一个标签来堵着，写法：
                                 .clearfix:before(前面的意思),.clearfix:after {
                                     content: "";
                                     display: table; (转换成表格类型)
                                 }
                                 .clearfix:after {
                                     clear:both;
                                 }
                                 .clearfix {
                                     *zoom:1;
                                 }

               5.额外标签法（隔墙法），给最后一个浮动的子元素后面添加一个块级元素类型的空标签拦一下。

    网页布局策略：为了约束浮动元素的位置，一般都是先用标准流的父元素控制排列上下的位置，内部的子元素采取浮动来排列左右的位置。

    导航栏制作：实际开发中，链接不直接写a标签，标准做法：用ul列表的li标签包裹。
               导航栏盒子尽量不给宽度，以便后期继续添加内容，内容会撑开盒子；每个a链接之间给左右padding值撑开距离。

    一个ul里有很多li时，一行排几个，可能内容多能排很多行，又必需每个li之间要设置外边距隔开空隙，那就会出现父盒子的宽装不下每个都设置了外边距的li盒子，这种情况建议给li的父盒子ul设置大点的宽度，能刚好装下设有外边距的一排几个盒子，反正li盒子多出来的外边距在网页上看不见。
    不建议给每行的第一个li或最后一个li取消外边距值，如果几十行，一个个写起来不太现实。    
    
    
3.定位（position）：主要作用：让盒子自由的在某个盒子内移动位置或者固定在屏幕中某个位置，并且可以压住其它标准流盒子，包括标准流盒子里的文字、图片等所有内容都会压住，和浮动的文字环绕效果完全不一样。
        行内元素设置定位属性后，可以直接设置宽高等属性。
        块级元素设置定位属性后，宽高默认是内容的宽高。原来没有设置时宽高默认占一行高，宽占满整个屏幕。
        脱标的盒子都不会触发外边距合并的问题。                        

静态定位(static)：什么作用都没有，不能使用边偏移属性，基本不用，是定位属性的默认值，给元素加了它元素还是只有标准流的属性。

相对定位(relative)：以自己原先的位置为参考坐标，并保留原先的位置，不脱标。

绝对定位(absolute)：以最近一级的有定位的元素为参考坐标，如果到最大的html标签都没有设置定位，就以网页为参考坐标，不保留自己原先的位置，脱标。（子绝父相：子元素绝对定位（不占位置）不影响父元素内的其他兄弟元素，父元素相对定位（占原来的位置）不会让父元素下面的标准流元素往上跑，乱了页面布局。

固定定位(fixed)：以浏览器的可视窗口为参照坐标（跟父元素没有任何关系），不随着滚动条的滚动而动，不占原先的位置，脱标。

粘性定位(sticky)：以浏览器的可视窗口为参照坐标（这是固定定位的部分特点），占有原先的位置（这是相对定位的特点），不脱标，必需设置一个边偏移属性粘性定位才有效。所以粘性定位可以看作固定定位和相对定位的混合，它会随着滚动条的滚动而动，但动到一定位置就会停下来固定住。兼容性差，目前IE不支持，较少用。

        定位的叠放次序：z-index来控制盒子的前后次序（z是z轴,三维坐标，z是屏幕朝脸的这一条坐标），这是定位专有属性，其它的都不可以用（就是只有设置定位属性的盒子才有z-index属性用）。  
        使用布局定位时，可能会出现定位到相同的位置，盒子重叠的情况，此时用z-index属性的值来决定哪个盒子在上层，哪个在底下被盖住，属性值不能带单位（px),值可以是正整数、负整数或0，默认值是auto，值越大，盒子越在上层，如果值相同，则按照盒子的书写顺序，后来居上。 
        嵌套情况下：父盒子和子盒子都有z-index属性，父低子高，去和父同级别的盒子进行比较，此时子的层级设置的再高都不起作用，如果父盒子没有设置层级，子盒子的层级才会生效去和父的同级别盒子比较。   
        
display属性：有很多属性值。
         1.转换元素类型的值有：
            inline(行内元素)
            inline-block(行内块元素)
            block(块级元素,此元素前后会带有换行符,所以独占一行显示)
            flex（Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。）

            list-item	此元素会作为列表显示
            run-in	此元素会根据上下文作为块级元素或内联元素显示
            table	此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。
            inline-table	此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。
            table-row-group	此元素会作为一个或多个行的分组来显示（类似 <tbody>）。
            table-header-group	此元素会作为一个或多个行的分组来显示（类似 <thead>）。
            table-footer-group	此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。
            table-row	此元素会作为一个表格行显示（类似 <tr>）。
            table-column-group	此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。
            table-column	此元素会作为一个单元格列显示（类似 <col>）
            table-cell	此元素会作为一个表格单元格显示（类似 <td> 和 <th>）
            table-caption	此元素会作为一个表格标题显示（类似 <caption>）
            inherit	规定应该从父元素继承 display 属性的值。
            
         2.隐藏元素和显示元素的值有两种：none(隐藏元素),元素被隐藏后不保留原来位置
           block(显示元素，block值有两种作用。)
        
visibility（可见性）属性：
    常用值：
        inherit(继承上一个父对象的可见性，父元素可见，它就可见，父元素不可见，它就不可见)、visible(对象可视)、hidden（对象隐藏）这里隐藏了会保留对象的原来位置，和display的none不一样。
        collapse（主要用来隐藏表格的行或列的，隐藏的行或列能被其它内容使用。对于表格外的其它对象，其作用等同于hidden。

overflow（溢出）属性：visible(显示内容，是默认值，不用设置)、hidden（隐藏，超出盒子大小的部分隐藏不显示）、scroll（显示滚动条，溢出或不溢出都有滚动条）、auto（自动，溢出就会显示滚动条，不溢出就没有滚动条）
        让溢出的文字显示省略号,元素必需要有固定的宽度，两种：
            1.单行显示省略号：
            white-space:nowrap（不换行）；（默认normal自动换行）   
            overflow:hidden;(超出的部分隐藏)
            text-overflow:ellipsis（省略号）;(文字超出的部分用省略号代替)   
            
            2.多行文本溢出显示省略号：不常用，兼容性差，IE不支持.
            overflow:hidden;
            text-overflow:ellipsis;
            display: -webkit-box;(转换成弹性伸缩盒子模型)
            -webkit-line-clamp:2;(设置在第几行显示省略号)
            -webkit-box-orient:vertical;（设置里面的子元素垂直居中）


vertical(垂直的)-align(对齐)属性：baseline(默认值，图片和文字基线对齐)、middle（让图片和文字居中对齐 ）、top（让图片和文字顶端对齐）、bottom(让图片和文字底端对齐)。

该属性常用于设置图片或表单和文字垂直对齐的。但只对行内元素或行内块元素有效。
    所有的图片和父盒子底部都有一条缝隙，原因是因为行内元素和行内块元素都是默认基线对齐的特性，去掉底部缝隙有两种方法：
        1.用vertical-align属性，除了默认值baseline不能用，其它值都可以去除底部缝隙。（推荐使用第一种方法）
        2.把图片转换成块级元素，块级元素没有基线对齐的特性。                        

-->

<img src="../html学习练习/image/定位总结.png" alt="">

<img src="../html学习练习/image/垂直对齐的四条线.png" alt="" style="vertical-align: middle;">我要和这图垂直居中对齐
<br>column分栏布局
<!-- 
    column分栏布局：
        columns:width count 属性是一个简写属性，用于设置列宽和列数。表现出列之间怎么流动及多列之间的间隙和分割线，并且使用了列高平衡，除了最后一列，其他列的高度一样。
        column-count用来控制列的数量,有几列。
        column-width 用来控制每一列的最小宽度
        column-count和column-width 冲突的时候，分为栏数少的优先
        column-gap 控制栏之间的间隙，默认是有缝隙的，可以通过这个属性设置缝隙的大小。
        column-rule 规定分割线，和border设置基本一样，虚线，实线，颜色，粗细等都可以设置，是栏与栏之间的分割线，是一条竖着的线。
        column-span 跨栏显示，是合并栏（类似于合并列），值为all是全部合并，不写这个属性的时候是默认值none不合并，盒子里面的子元素谁需要合并写谁身上。
-->
等高布局的元素都不能设置高度，子元素浮动到一行显示
<!-- 
    等高布局：利用给所有子元素超大的负值margin-bottom，和同样大的正值padding-bottom，并且父元素和里面所有的子元素都不设置高度，再设置父元素溢出隐藏overflow：hidden；来实现父元素里的子元素一行排列时，所有子元素自动以最高的那个子元素为标准，把高度变得和最高的盒子一样高。

    实现原理，父盒子的高度要靠子盒子撑开，margin-bottom和padding-bottom值抵消时，对于父元素来说，子元素等于没有高度，撑不开父元素，但是子元素的正值padding让子元素的高度实际上是存在的，因为父盒子设置溢出隐藏了看不见，只有往子元素里面添内容才会把父盒子的高度撑开，内容撑开了父盒子，父盒子的高度是内容的高度决定的，在父盒子里面的子盒子露出的可视区域都相同，就实现等高布局了。
 -->
双飞翼布局和圣杯布局，三列子元素，两列宽度固定，其中一列不设置宽度，让它宽度自适应。
<!-- 
     双飞翼布局：
        1.先把所有子元素设置浮动到一行显示，
        2.给第一个子元素设置宽度100%，和父盒子同宽，父盒子不设置宽度，默认和浏览器同宽，第二个第三个子元素必需设置宽度，具体多宽按自己需求。
        3.第二第三个子元素设置margin-left值为负值，移到第一个子元素上面，覆盖它，如果放最左边，就移动margin-left：-100%；如果放最右边，就移动盒子自身的宽度负的值。
        4.第二第三个元素覆盖时也会覆盖第一个宽度自适应的盒子里的内容，所以要给里面的内容用标签包起来，再设置里面的包内容的那个标签margin左和右值为盒子的第二第三个盒子的宽度，左边的往右移就是正值，右边的往左移就是负值，看布局排版需求。这样内容就正确显示在没覆盖的区域了，内容标签的高度会因内容自适应，如果需要就将高度设置成100%，就是与父元素同高，完成布局。这种布局不管浏览器窗口放大还是缩小都能跟着浏览器窗口大小变化。
    圣杯布局：基本步骤和双飞翼布局一样，唯一的区别是：双飞翼布局里需要再写个标签包裹内容区域，圣杯布局可以直接用父元素当做包裹内容的标签，把父元素设置成包裹内容的标签需要如下步骤实现：
        1.把父元素的margin左右值设置成左右子元素的宽度值
        2.给两边的子元素添加定位，如果父元素相对定位，子元素绝对定位，如果父元素不设置定位，子元素相对定位，再把left和right值设置成负自身宽度值，抵消父元素的margin左右值。
        3.如果父元素不给高度，子元素给高度，要给父元素清除浮动，父元素高度才能被子元素撑开，否则就只能被内容撑开。如果给父元素高度，里面的子元素都可以用100%继承父元素的高度。
  -->
BFC布局概念
<!-- 
在解释什么是BFC之前，我们需要先知道Box（盒子）、Formatting Context（格式化上下文）的概念。

Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。
    元素的类型和 display 属性，决定了这个 Box 的类型。 
    不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。
    
    让我们看看有哪些box盒子：

        block-level box:
            display 属性为 block, list-item, table 的元素，会生成 block-level box（标准的块盒子）。并且参与 block fomatting context（块级格式化上下文，简称BFC）；

        inline-level box:
            display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box（标准的行内盒子）。并且参与 inline formatting context（内联格式化上下文，简称IFC）；
    
        run-in box: css3 中才有， 这儿先不讲了。

    Formatting context ：
        是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。
        最常见的 Formatting context 有:
            Block fomatting context (简称BFC)
            Inline formatting context (简称IFC)。

●BFC到底是什么？
    简单的来说：BFC就是一个css的一个布局概念，是一个独立的区域，是一个环境。
●BFC的定义
    BFC（Block formatting context ）“块级格式上下文”。 是用于布局块级盒子的一块渲染区域。并且与这个区域的外部毫无关系。
●BFC的布局规则
    内部的Box会在垂直方向，一个接一个地放置。

    Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。

    每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。

    BFC的区域不会与float box重叠。

    BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

    计算BFC的高度时，浮动元素也参与计算。

●触发BFC的条件
    满足下列条件之一就可以触发BFC：
            1：根元素，即html元素
            2：float的值不为none
            3：overflow的值不为visible
            4：display的值为inline-block、inline-flex、flex、flow-root、table-caption、table-cell。
            5：position的值为absolute或者fixed

●BFC的作用
    BFC是页面独立的一个容器，与外界的毫无关系。在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。

    1：可以阻止元素被浮动的元素覆盖（可做两栏布局自适应,就是两个块级元素能一行排列，第二个元素可以不给固定宽度，让它自适应，而且它里面的内容能正常靠左沿着父元素边框显示，例如文字不会被浮动元素覆盖而环绕在浮动元素周围）。
    解决方法第二个盒子可以设置以下样式，触发BFC布局概念：
        float: left; 
        display: inline-block; 
        display: table-cell; 
        overflow: hidden; 
        position: absolute; 
        position: fixed; 

    2.解决margin传递问题，就是子元素浮动，父元素没有高度时，会出现高度塌陷现象（标准流的盒子默认子元素的高度会撑开父元素，父元素不设置高度也会和子元素一样高，但子元素设置浮动后不占空间，父元素的高度就会因为没有设置变成0）。
    解决方法父盒子设置：
        overflow：hidden；
        overflow：auto；
    3.解决同一个BFC区域的元素垂直方向margin塌陷的问题，两个相邻的盒子的margin会重叠，上面盒子的margin-bottom会和下面盒子的margin-top重叠，谁的属性值设置的大就取大的值，这时两个盒子之间的距离实际只有那个大的值的距离。例如上面的盒子margin-bottom：10px；下面盒子的margin-top30px，它们之间的外边距就是30px，而不是应该正常显示的40px，要想解决这个问题，要不就把40px总的累加值写在一个盒子身上，要不就用BFC布局概念。
    解决方法下面的盒子设置：
        overflow：hidden；
        display:inline-block
    4.嵌套元素的margin-top传递问题，子盒子设置了margin-top后会把父盒子也带着往下，子盒子上边依然紧挨着父盒子上边，而不是父盒子不动，子盒子自己往下与父盒子拉开间距。
    解决方法父盒子设置：
        overflow：hidden；
        position:absolute;

 -->